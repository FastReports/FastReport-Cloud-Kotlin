/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package cloud.fastreport.client

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import cloud.fastreport.model.AuditActionsVM
import cloud.fastreport.model.BreadcrumbsVM
import cloud.fastreport.model.CountVM
import cloud.fastreport.model.CreateFileShareVM
import cloud.fastreport.model.ExportFolderCreateVM
import cloud.fastreport.model.ExportVM
import cloud.fastreport.model.ExportsVM
import cloud.fastreport.model.FileIconVM
import cloud.fastreport.model.FilePermissionsVM
import cloud.fastreport.model.FileRenameVM
import cloud.fastreport.model.FileSharingKeysVM
import cloud.fastreport.model.FileSorting
import cloud.fastreport.model.FileTagsUpdateVM
import cloud.fastreport.model.FileVM
import cloud.fastreport.model.FilesVM
import cloud.fastreport.model.FolderIconVM
import cloud.fastreport.model.FolderRenameVM
import cloud.fastreport.model.FolderSizeVM
import cloud.fastreport.model.FolderTagsUpdateVM
import cloud.fastreport.model.ProblemDetails
import cloud.fastreport.model.SelectedFilesVM
import cloud.fastreport.model.UpdateFilePermissionsVM

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class ExportsApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
     * Delete all folders and files from recycle bin
     * User with a Delete RecycleBin permission can access this method.
     * @param subscriptionId subscription id
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exportFolderAndFileClearRecycleBin(subscriptionId: kotlin.String) : Unit {
        val localVarResponse = exportFolderAndFileClearRecycleBinWithHttpInfo(subscriptionId = subscriptionId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete all folders and files from recycle bin
     * User with a Delete RecycleBin permission can access this method.
     * @param subscriptionId subscription id
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun exportFolderAndFileClearRecycleBinWithHttpInfo(subscriptionId: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = exportFolderAndFileClearRecycleBinRequestConfig(subscriptionId = subscriptionId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exportFolderAndFileClearRecycleBin
     *
     * @param subscriptionId subscription id
     * @return RequestConfig
     */
    fun exportFolderAndFileClearRecycleBinRequestConfig(subscriptionId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/rp/v1/Exports/{subscriptionId}/ClearRecycleBin".replace("{"+"subscriptionId"+"}", encodeURIComponent(subscriptionId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Copy folders and files to a specified folder
     * User with a Get permission for a files and Create permission for a destination folder can access this method.
     * @param subscriptionId id of current subscription
     * @param selectedFilesVM VM with files&#39; ids and params of their destination (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exportFolderAndFileCopyFiles(subscriptionId: kotlin.String, selectedFilesVM: SelectedFilesVM? = null) : Unit {
        val localVarResponse = exportFolderAndFileCopyFilesWithHttpInfo(subscriptionId = subscriptionId, selectedFilesVM = selectedFilesVM)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Copy folders and files to a specified folder
     * User with a Get permission for a files and Create permission for a destination folder can access this method.
     * @param subscriptionId id of current subscription
     * @param selectedFilesVM VM with files&#39; ids and params of their destination (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun exportFolderAndFileCopyFilesWithHttpInfo(subscriptionId: kotlin.String, selectedFilesVM: SelectedFilesVM?) : ApiResponse<Unit?> {
        val localVariableConfig = exportFolderAndFileCopyFilesRequestConfig(subscriptionId = subscriptionId, selectedFilesVM = selectedFilesVM)

        return request<SelectedFilesVM, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exportFolderAndFileCopyFiles
     *
     * @param subscriptionId id of current subscription
     * @param selectedFilesVM VM with files&#39; ids and params of their destination (optional)
     * @return RequestConfig
     */
    fun exportFolderAndFileCopyFilesRequestConfig(subscriptionId: kotlin.String, selectedFilesVM: SelectedFilesVM?) : RequestConfig<SelectedFilesVM> {
        val localVariableBody = selectedFilesVM
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/rp/v1/Exports/{subscriptionId}/CopyFiles".replace("{"+"subscriptionId"+"}", encodeURIComponent(subscriptionId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Count all folders and files from recycle bin
     * User with a Get DeletedFiles permission can access this method.
     * @param subscriptionId subscription id
     * @param searchPattern  (optional, default to "")
     * @param useRegex  (optional, default to false)
     * @return CountVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exportFolderAndFileCountRecycleBinFoldersAndFiles(subscriptionId: kotlin.String, searchPattern: kotlin.String? = "", useRegex: kotlin.Boolean? = false) : CountVM {
        val localVarResponse = exportFolderAndFileCountRecycleBinFoldersAndFilesWithHttpInfo(subscriptionId = subscriptionId, searchPattern = searchPattern, useRegex = useRegex)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CountVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Count all folders and files from recycle bin
     * User with a Get DeletedFiles permission can access this method.
     * @param subscriptionId subscription id
     * @param searchPattern  (optional, default to "")
     * @param useRegex  (optional, default to false)
     * @return ApiResponse<CountVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun exportFolderAndFileCountRecycleBinFoldersAndFilesWithHttpInfo(subscriptionId: kotlin.String, searchPattern: kotlin.String?, useRegex: kotlin.Boolean?) : ApiResponse<CountVM?> {
        val localVariableConfig = exportFolderAndFileCountRecycleBinFoldersAndFilesRequestConfig(subscriptionId = subscriptionId, searchPattern = searchPattern, useRegex = useRegex)

        return request<Unit, CountVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exportFolderAndFileCountRecycleBinFoldersAndFiles
     *
     * @param subscriptionId subscription id
     * @param searchPattern  (optional, default to "")
     * @param useRegex  (optional, default to false)
     * @return RequestConfig
     */
    fun exportFolderAndFileCountRecycleBinFoldersAndFilesRequestConfig(subscriptionId: kotlin.String, searchPattern: kotlin.String?, useRegex: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (searchPattern != null) {
                    put("searchPattern", listOf(searchPattern.toString()))
                }
                if (useRegex != null) {
                    put("useRegex", listOf(useRegex.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/rp/v1/Exports/{subscriptionId}/CountRecycleBinFolderAndFiles".replace("{"+"subscriptionId"+"}", encodeURIComponent(subscriptionId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Delete folders and files
     * User with a Delete permission can access this method.
     * @param subscriptionId id of current subscription
     * @param selectedFilesVM VM with files&#39; ids and params of their destination (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exportFolderAndFileDeleteFiles(subscriptionId: kotlin.String, selectedFilesVM: SelectedFilesVM? = null) : Unit {
        val localVarResponse = exportFolderAndFileDeleteFilesWithHttpInfo(subscriptionId = subscriptionId, selectedFilesVM = selectedFilesVM)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete folders and files
     * User with a Delete permission can access this method.
     * @param subscriptionId id of current subscription
     * @param selectedFilesVM VM with files&#39; ids and params of their destination (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun exportFolderAndFileDeleteFilesWithHttpInfo(subscriptionId: kotlin.String, selectedFilesVM: SelectedFilesVM?) : ApiResponse<Unit?> {
        val localVariableConfig = exportFolderAndFileDeleteFilesRequestConfig(subscriptionId = subscriptionId, selectedFilesVM = selectedFilesVM)

        return request<SelectedFilesVM, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exportFolderAndFileDeleteFiles
     *
     * @param subscriptionId id of current subscription
     * @param selectedFilesVM VM with files&#39; ids and params of their destination (optional)
     * @return RequestConfig
     */
    fun exportFolderAndFileDeleteFilesRequestConfig(subscriptionId: kotlin.String, selectedFilesVM: SelectedFilesVM?) : RequestConfig<SelectedFilesVM> {
        val localVariableBody = selectedFilesVM
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/rp/v1/Exports/{subscriptionId}/DeleteFiles".replace("{"+"subscriptionId"+"}", encodeURIComponent(subscriptionId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get count of files and folders what contains in a specified folder
     * User with a Get Count permission can access this method.
     * @param id folder id
     * @param searchPattern string, that must be incuded in file or folder name to be counted &lt;br /&gt;              (leave undefined to count all files and folders) (optional)
     * @param useRegex set this to true if you want to use regular expression to search (optional, default to false)
     * @return CountVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exportFolderAndFileGetCount(id: kotlin.String, searchPattern: kotlin.String? = null, useRegex: kotlin.Boolean? = false) : CountVM {
        val localVarResponse = exportFolderAndFileGetCountWithHttpInfo(id = id, searchPattern = searchPattern, useRegex = useRegex)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CountVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get count of files and folders what contains in a specified folder
     * User with a Get Count permission can access this method.
     * @param id folder id
     * @param searchPattern string, that must be incuded in file or folder name to be counted &lt;br /&gt;              (leave undefined to count all files and folders) (optional)
     * @param useRegex set this to true if you want to use regular expression to search (optional, default to false)
     * @return ApiResponse<CountVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun exportFolderAndFileGetCountWithHttpInfo(id: kotlin.String, searchPattern: kotlin.String?, useRegex: kotlin.Boolean?) : ApiResponse<CountVM?> {
        val localVariableConfig = exportFolderAndFileGetCountRequestConfig(id = id, searchPattern = searchPattern, useRegex = useRegex)

        return request<Unit, CountVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exportFolderAndFileGetCount
     *
     * @param id folder id
     * @param searchPattern string, that must be incuded in file or folder name to be counted &lt;br /&gt;              (leave undefined to count all files and folders) (optional)
     * @param useRegex set this to true if you want to use regular expression to search (optional, default to false)
     * @return RequestConfig
     */
    fun exportFolderAndFileGetCountRequestConfig(id: kotlin.String, searchPattern: kotlin.String?, useRegex: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (searchPattern != null) {
                    put("searchPattern", listOf(searchPattern.toString()))
                }
                if (useRegex != null) {
                    put("useRegex", listOf(useRegex.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/rp/v1/Exports/Folder/{id}/CountFolderAndFiles".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get all folders and files from specified folder
     * User with a Get Entity permission can access this method.
     * @param id folder id
     * @param skip number of folder and files, that have to be skipped (optional, default to 0)
     * @param take number of folder and files, that have to be returned (optional, default to 10)
     * @param orderBy indicates a field to sort by (optional)
     * @param desc indicates if sorting is descending (optional, default to false)
     * @param searchPattern  (optional, default to "")
     * @param useRegex  (optional, default to false)
     * @return FilesVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exportFolderAndFileGetFoldersAndFiles(id: kotlin.String, skip: kotlin.Int? = 0, take: kotlin.Int? = 10, orderBy: FileSorting? = null, desc: kotlin.Boolean? = false, searchPattern: kotlin.String? = "", useRegex: kotlin.Boolean? = false) : FilesVM {
        val localVarResponse = exportFolderAndFileGetFoldersAndFilesWithHttpInfo(id = id, skip = skip, take = take, orderBy = orderBy, desc = desc, searchPattern = searchPattern, useRegex = useRegex)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FilesVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get all folders and files from specified folder
     * User with a Get Entity permission can access this method.
     * @param id folder id
     * @param skip number of folder and files, that have to be skipped (optional, default to 0)
     * @param take number of folder and files, that have to be returned (optional, default to 10)
     * @param orderBy indicates a field to sort by (optional)
     * @param desc indicates if sorting is descending (optional, default to false)
     * @param searchPattern  (optional, default to "")
     * @param useRegex  (optional, default to false)
     * @return ApiResponse<FilesVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun exportFolderAndFileGetFoldersAndFilesWithHttpInfo(id: kotlin.String, skip: kotlin.Int?, take: kotlin.Int?, orderBy: FileSorting?, desc: kotlin.Boolean?, searchPattern: kotlin.String?, useRegex: kotlin.Boolean?) : ApiResponse<FilesVM?> {
        val localVariableConfig = exportFolderAndFileGetFoldersAndFilesRequestConfig(id = id, skip = skip, take = take, orderBy = orderBy, desc = desc, searchPattern = searchPattern, useRegex = useRegex)

        return request<Unit, FilesVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exportFolderAndFileGetFoldersAndFiles
     *
     * @param id folder id
     * @param skip number of folder and files, that have to be skipped (optional, default to 0)
     * @param take number of folder and files, that have to be returned (optional, default to 10)
     * @param orderBy indicates a field to sort by (optional)
     * @param desc indicates if sorting is descending (optional, default to false)
     * @param searchPattern  (optional, default to "")
     * @param useRegex  (optional, default to false)
     * @return RequestConfig
     */
    fun exportFolderAndFileGetFoldersAndFilesRequestConfig(id: kotlin.String, skip: kotlin.Int?, take: kotlin.Int?, orderBy: FileSorting?, desc: kotlin.Boolean?, searchPattern: kotlin.String?, useRegex: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (skip != null) {
                    put("skip", listOf(skip.toString()))
                }
                if (take != null) {
                    put("take", listOf(take.toString()))
                }
                if (orderBy != null) {
                    put("orderBy", listOf(orderBy.toString()))
                }
                if (desc != null) {
                    put("desc", listOf(desc.toString()))
                }
                if (searchPattern != null) {
                    put("searchPattern", listOf(searchPattern.toString()))
                }
                if (useRegex != null) {
                    put("useRegex", listOf(useRegex.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/rp/v1/Exports/Folder/{id}/ListFolderAndFiles".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get all folders and files from recycle bin
     * User with a Get DeletedFiles permission can access this method.
     * @param subscriptionId subscription id
     * @param skip number of folder and files, that have to be skipped (optional, default to 0)
     * @param take number of folder and files, that have to be returned (optional, default to 10)
     * @param orderBy indicates a field to sort by (optional)
     * @param desc indicates if sorting is descending (optional, default to false)
     * @param searchPattern  (optional, default to "")
     * @param useRegex  (optional, default to false)
     * @return FilesVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exportFolderAndFileGetRecycleBinFoldersAndFiles(subscriptionId: kotlin.String, skip: kotlin.Int? = 0, take: kotlin.Int? = 10, orderBy: FileSorting? = null, desc: kotlin.Boolean? = false, searchPattern: kotlin.String? = "", useRegex: kotlin.Boolean? = false) : FilesVM {
        val localVarResponse = exportFolderAndFileGetRecycleBinFoldersAndFilesWithHttpInfo(subscriptionId = subscriptionId, skip = skip, take = take, orderBy = orderBy, desc = desc, searchPattern = searchPattern, useRegex = useRegex)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FilesVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get all folders and files from recycle bin
     * User with a Get DeletedFiles permission can access this method.
     * @param subscriptionId subscription id
     * @param skip number of folder and files, that have to be skipped (optional, default to 0)
     * @param take number of folder and files, that have to be returned (optional, default to 10)
     * @param orderBy indicates a field to sort by (optional)
     * @param desc indicates if sorting is descending (optional, default to false)
     * @param searchPattern  (optional, default to "")
     * @param useRegex  (optional, default to false)
     * @return ApiResponse<FilesVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun exportFolderAndFileGetRecycleBinFoldersAndFilesWithHttpInfo(subscriptionId: kotlin.String, skip: kotlin.Int?, take: kotlin.Int?, orderBy: FileSorting?, desc: kotlin.Boolean?, searchPattern: kotlin.String?, useRegex: kotlin.Boolean?) : ApiResponse<FilesVM?> {
        val localVariableConfig = exportFolderAndFileGetRecycleBinFoldersAndFilesRequestConfig(subscriptionId = subscriptionId, skip = skip, take = take, orderBy = orderBy, desc = desc, searchPattern = searchPattern, useRegex = useRegex)

        return request<Unit, FilesVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exportFolderAndFileGetRecycleBinFoldersAndFiles
     *
     * @param subscriptionId subscription id
     * @param skip number of folder and files, that have to be skipped (optional, default to 0)
     * @param take number of folder and files, that have to be returned (optional, default to 10)
     * @param orderBy indicates a field to sort by (optional)
     * @param desc indicates if sorting is descending (optional, default to false)
     * @param searchPattern  (optional, default to "")
     * @param useRegex  (optional, default to false)
     * @return RequestConfig
     */
    fun exportFolderAndFileGetRecycleBinFoldersAndFilesRequestConfig(subscriptionId: kotlin.String, skip: kotlin.Int?, take: kotlin.Int?, orderBy: FileSorting?, desc: kotlin.Boolean?, searchPattern: kotlin.String?, useRegex: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (skip != null) {
                    put("skip", listOf(skip.toString()))
                }
                if (take != null) {
                    put("take", listOf(take.toString()))
                }
                if (orderBy != null) {
                    put("orderBy", listOf(orderBy.toString()))
                }
                if (desc != null) {
                    put("desc", listOf(desc.toString()))
                }
                if (searchPattern != null) {
                    put("searchPattern", listOf(searchPattern.toString()))
                }
                if (useRegex != null) {
                    put("useRegex", listOf(useRegex.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/rp/v1/Exports/{subscriptionId}/ListRecycleBinFolderAndFiles".replace("{"+"subscriptionId"+"}", encodeURIComponent(subscriptionId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Move folders and files to a specified folder
     * User with a Update Place permission for a files and Create permission for a destination folder can access this method.
     * @param subscriptionId id of current subscription
     * @param selectedFilesVM VM with files&#39; ids and params of their destination (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exportFolderAndFileMoveFiles(subscriptionId: kotlin.String, selectedFilesVM: SelectedFilesVM? = null) : Unit {
        val localVarResponse = exportFolderAndFileMoveFilesWithHttpInfo(subscriptionId = subscriptionId, selectedFilesVM = selectedFilesVM)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Move folders and files to a specified folder
     * User with a Update Place permission for a files and Create permission for a destination folder can access this method.
     * @param subscriptionId id of current subscription
     * @param selectedFilesVM VM with files&#39; ids and params of their destination (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun exportFolderAndFileMoveFilesWithHttpInfo(subscriptionId: kotlin.String, selectedFilesVM: SelectedFilesVM?) : ApiResponse<Unit?> {
        val localVariableConfig = exportFolderAndFileMoveFilesRequestConfig(subscriptionId = subscriptionId, selectedFilesVM = selectedFilesVM)

        return request<SelectedFilesVM, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exportFolderAndFileMoveFiles
     *
     * @param subscriptionId id of current subscription
     * @param selectedFilesVM VM with files&#39; ids and params of their destination (optional)
     * @return RequestConfig
     */
    fun exportFolderAndFileMoveFilesRequestConfig(subscriptionId: kotlin.String, selectedFilesVM: SelectedFilesVM?) : RequestConfig<SelectedFilesVM> {
        val localVariableBody = selectedFilesVM
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/rp/v1/Exports/{subscriptionId}/MoveFiles".replace("{"+"subscriptionId"+"}", encodeURIComponent(subscriptionId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Move folders and files to bin
     * User with a Delete permission can access this method.
     * @param subscriptionId id of current subscription
     * @param selectedFilesVM VM with files&#39; ids and params of their destination (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exportFolderAndFileMoveFilesToBin(subscriptionId: kotlin.String, selectedFilesVM: SelectedFilesVM? = null) : Unit {
        val localVarResponse = exportFolderAndFileMoveFilesToBinWithHttpInfo(subscriptionId = subscriptionId, selectedFilesVM = selectedFilesVM)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Move folders and files to bin
     * User with a Delete permission can access this method.
     * @param subscriptionId id of current subscription
     * @param selectedFilesVM VM with files&#39; ids and params of their destination (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun exportFolderAndFileMoveFilesToBinWithHttpInfo(subscriptionId: kotlin.String, selectedFilesVM: SelectedFilesVM?) : ApiResponse<Unit?> {
        val localVariableConfig = exportFolderAndFileMoveFilesToBinRequestConfig(subscriptionId = subscriptionId, selectedFilesVM = selectedFilesVM)

        return request<SelectedFilesVM, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exportFolderAndFileMoveFilesToBin
     *
     * @param subscriptionId id of current subscription
     * @param selectedFilesVM VM with files&#39; ids and params of their destination (optional)
     * @return RequestConfig
     */
    fun exportFolderAndFileMoveFilesToBinRequestConfig(subscriptionId: kotlin.String, selectedFilesVM: SelectedFilesVM?) : RequestConfig<SelectedFilesVM> {
        val localVariableBody = selectedFilesVM
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/rp/v1/Exports/{subscriptionId}/ToBin".replace("{"+"subscriptionId"+"}", encodeURIComponent(subscriptionId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Recover all folders and files from recycle bin
     * User with a Create RecycleBin permission can access this method.
     * @param subscriptionId subscription id
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exportFolderAndFileRecoverAllFromRecycleBin(subscriptionId: kotlin.String) : Unit {
        val localVarResponse = exportFolderAndFileRecoverAllFromRecycleBinWithHttpInfo(subscriptionId = subscriptionId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Recover all folders and files from recycle bin
     * User with a Create RecycleBin permission can access this method.
     * @param subscriptionId subscription id
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun exportFolderAndFileRecoverAllFromRecycleBinWithHttpInfo(subscriptionId: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = exportFolderAndFileRecoverAllFromRecycleBinRequestConfig(subscriptionId = subscriptionId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exportFolderAndFileRecoverAllFromRecycleBin
     *
     * @param subscriptionId subscription id
     * @return RequestConfig
     */
    fun exportFolderAndFileRecoverAllFromRecycleBinRequestConfig(subscriptionId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/rp/v1/Exports/{subscriptionId}/RecoverRecycleBin".replace("{"+"subscriptionId"+"}", encodeURIComponent(subscriptionId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Recover folders and files from bin
     * User with a SubscriptionCreate permission can access this method.
     * @param subscriptionId id of current subscription
     * @param selectedFilesVM VM with files&#39; ids and params of their destination (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exportFolderAndFileRecoverFiles(subscriptionId: kotlin.String, selectedFilesVM: SelectedFilesVM? = null) : Unit {
        val localVarResponse = exportFolderAndFileRecoverFilesWithHttpInfo(subscriptionId = subscriptionId, selectedFilesVM = selectedFilesVM)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Recover folders and files from bin
     * User with a SubscriptionCreate permission can access this method.
     * @param subscriptionId id of current subscription
     * @param selectedFilesVM VM with files&#39; ids and params of their destination (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun exportFolderAndFileRecoverFilesWithHttpInfo(subscriptionId: kotlin.String, selectedFilesVM: SelectedFilesVM?) : ApiResponse<Unit?> {
        val localVariableConfig = exportFolderAndFileRecoverFilesRequestConfig(subscriptionId = subscriptionId, selectedFilesVM = selectedFilesVM)

        return request<SelectedFilesVM, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exportFolderAndFileRecoverFiles
     *
     * @param subscriptionId id of current subscription
     * @param selectedFilesVM VM with files&#39; ids and params of their destination (optional)
     * @return RequestConfig
     */
    fun exportFolderAndFileRecoverFilesRequestConfig(subscriptionId: kotlin.String, selectedFilesVM: SelectedFilesVM?) : RequestConfig<SelectedFilesVM> {
        val localVariableBody = selectedFilesVM
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/rp/v1/Exports/{subscriptionId}/RecoverFiles".replace("{"+"subscriptionId"+"}", encodeURIComponent(subscriptionId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get specified folder, calculate it&#39;s size
     * User with a Get Entity permission can access this method.
     * @param id folder id
     * @return FolderSizeVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exportFoldersCalculateFolderSize(id: kotlin.String) : FolderSizeVM {
        val localVarResponse = exportFoldersCalculateFolderSizeWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FolderSizeVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get specified folder, calculate it&#39;s size
     * User with a Get Entity permission can access this method.
     * @param id folder id
     * @return ApiResponse<FolderSizeVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun exportFoldersCalculateFolderSizeWithHttpInfo(id: kotlin.String) : ApiResponse<FolderSizeVM?> {
        val localVariableConfig = exportFoldersCalculateFolderSizeRequestConfig(id = id)

        return request<Unit, FolderSizeVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exportFoldersCalculateFolderSize
     *
     * @param id folder id
     * @return RequestConfig
     */
    fun exportFoldersCalculateFolderSizeRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/rp/v1/Exports/Folder/{id}/size".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Move folder to a specified folder
     * User with a Update Place permission for a folder and Create Entity  for a Parent Folder can access this method.
     * @param id moving folder id
     * @param folderId destination folder id
     * @return FileVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exportFoldersCopyFolder(id: kotlin.String, folderId: kotlin.String) : FileVM {
        val localVarResponse = exportFoldersCopyFolderWithHttpInfo(id = id, folderId = folderId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FileVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Move folder to a specified folder
     * User with a Update Place permission for a folder and Create Entity  for a Parent Folder can access this method.
     * @param id moving folder id
     * @param folderId destination folder id
     * @return ApiResponse<FileVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun exportFoldersCopyFolderWithHttpInfo(id: kotlin.String, folderId: kotlin.String) : ApiResponse<FileVM?> {
        val localVariableConfig = exportFoldersCopyFolderRequestConfig(id = id, folderId = folderId)

        return request<Unit, FileVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exportFoldersCopyFolder
     *
     * @param id moving folder id
     * @param folderId destination folder id
     * @return RequestConfig
     */
    fun exportFoldersCopyFolderRequestConfig(id: kotlin.String, folderId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/rp/v1/Exports/Folder/{id}/Copy/{folderId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"folderId"+"}", encodeURIComponent(folderId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Delete specified folder
     * User with a Delete Entity permission can access this method.
     * @param id folder id
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exportFoldersDeleteFolder(id: kotlin.String) : Unit {
        val localVarResponse = exportFoldersDeleteFolderWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete specified folder
     * User with a Delete Entity permission can access this method.
     * @param id folder id
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun exportFoldersDeleteFolderWithHttpInfo(id: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = exportFoldersDeleteFolderRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exportFoldersDeleteFolder
     *
     * @param id folder id
     * @return RequestConfig
     */
    fun exportFoldersDeleteFolderRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/rp/v1/Exports/Folder/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get specified folder breadcrumbs
     * User with a Get Entity permission can access this method.
     * @param id folder id
     * @return BreadcrumbsVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exportFoldersGetBreadcrumbs(id: kotlin.String) : BreadcrumbsVM {
        val localVarResponse = exportFoldersGetBreadcrumbsWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BreadcrumbsVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get specified folder breadcrumbs
     * User with a Get Entity permission can access this method.
     * @param id folder id
     * @return ApiResponse<BreadcrumbsVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun exportFoldersGetBreadcrumbsWithHttpInfo(id: kotlin.String) : ApiResponse<BreadcrumbsVM?> {
        val localVariableConfig = exportFoldersGetBreadcrumbsRequestConfig(id = id)

        return request<Unit, BreadcrumbsVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exportFoldersGetBreadcrumbs
     *
     * @param id folder id
     * @return RequestConfig
     */
    fun exportFoldersGetBreadcrumbsRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/rp/v1/Exports/Folder/{id}/Breadcrumbs".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get specified folder
     * User with a Get Entity permission can access this method.
     * @param id folder id
     * @return FileVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exportFoldersGetFolder(id: kotlin.String) : FileVM {
        val localVarResponse = exportFoldersGetFolderWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FileVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get specified folder
     * User with a Get Entity permission can access this method.
     * @param id folder id
     * @return ApiResponse<FileVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun exportFoldersGetFolderWithHttpInfo(id: kotlin.String) : ApiResponse<FileVM?> {
        val localVariableConfig = exportFoldersGetFolderRequestConfig(id = id)

        return request<Unit, FileVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exportFoldersGetFolder
     *
     * @param id folder id
     * @return RequestConfig
     */
    fun exportFoldersGetFolderRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/rp/v1/Exports/Folder/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get all folders from specified folder
     * User with a Get Entity permission can access this method.
     * @param id folder id
     * @param skip number of files, that have to be skipped (optional, default to 0)
     * @param take number of files, that have to be returned (optional, default to 10)
     * @param orderBy  (optional)
     * @param desc  (optional, default to false)
     * @param searchPattern  (optional, default to "")
     * @param useRegex  (optional, default to false)
     * @return FilesVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exportFoldersGetFolders(id: kotlin.String, skip: kotlin.Int? = 0, take: kotlin.Int? = 10, orderBy: FileSorting? = null, desc: kotlin.Boolean? = false, searchPattern: kotlin.String? = "", useRegex: kotlin.Boolean? = false) : FilesVM {
        val localVarResponse = exportFoldersGetFoldersWithHttpInfo(id = id, skip = skip, take = take, orderBy = orderBy, desc = desc, searchPattern = searchPattern, useRegex = useRegex)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FilesVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get all folders from specified folder
     * User with a Get Entity permission can access this method.
     * @param id folder id
     * @param skip number of files, that have to be skipped (optional, default to 0)
     * @param take number of files, that have to be returned (optional, default to 10)
     * @param orderBy  (optional)
     * @param desc  (optional, default to false)
     * @param searchPattern  (optional, default to "")
     * @param useRegex  (optional, default to false)
     * @return ApiResponse<FilesVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun exportFoldersGetFoldersWithHttpInfo(id: kotlin.String, skip: kotlin.Int?, take: kotlin.Int?, orderBy: FileSorting?, desc: kotlin.Boolean?, searchPattern: kotlin.String?, useRegex: kotlin.Boolean?) : ApiResponse<FilesVM?> {
        val localVariableConfig = exportFoldersGetFoldersRequestConfig(id = id, skip = skip, take = take, orderBy = orderBy, desc = desc, searchPattern = searchPattern, useRegex = useRegex)

        return request<Unit, FilesVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exportFoldersGetFolders
     *
     * @param id folder id
     * @param skip number of files, that have to be skipped (optional, default to 0)
     * @param take number of files, that have to be returned (optional, default to 10)
     * @param orderBy  (optional)
     * @param desc  (optional, default to false)
     * @param searchPattern  (optional, default to "")
     * @param useRegex  (optional, default to false)
     * @return RequestConfig
     */
    fun exportFoldersGetFoldersRequestConfig(id: kotlin.String, skip: kotlin.Int?, take: kotlin.Int?, orderBy: FileSorting?, desc: kotlin.Boolean?, searchPattern: kotlin.String?, useRegex: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (skip != null) {
                    put("skip", listOf(skip.toString()))
                }
                if (take != null) {
                    put("take", listOf(take.toString()))
                }
                if (orderBy != null) {
                    put("orderBy", listOf(orderBy.toString()))
                }
                if (desc != null) {
                    put("desc", listOf(desc.toString()))
                }
                if (searchPattern != null) {
                    put("searchPattern", listOf(searchPattern.toString()))
                }
                if (useRegex != null) {
                    put("useRegex", listOf(useRegex.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/rp/v1/Exports/Folder/{id}/ListFolders".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get count of folders what contains in a specified folder
     * User with a Get Count permission can access this method.
     * @param id folder id
     * @return CountVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exportFoldersGetFoldersCount(id: kotlin.String) : CountVM {
        val localVarResponse = exportFoldersGetFoldersCountWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CountVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get count of folders what contains in a specified folder
     * User with a Get Count permission can access this method.
     * @param id folder id
     * @return ApiResponse<CountVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun exportFoldersGetFoldersCountWithHttpInfo(id: kotlin.String) : ApiResponse<CountVM?> {
        val localVariableConfig = exportFoldersGetFoldersCountRequestConfig(id = id)

        return request<Unit, CountVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exportFoldersGetFoldersCount
     *
     * @param id folder id
     * @return RequestConfig
     */
    fun exportFoldersGetFoldersCountRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/rp/v1/Exports/Folder/{id}/CountFolders".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get specified folder
     * User with a Get Entity permission can access this method.
     * @param name folder name (optional)
     * @param subscriptionId subscriptionId (optional)
     * @param parentId parent folder id (optional)
     * @return FileVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exportFoldersGetOrCreate(name: kotlin.String? = null, subscriptionId: kotlin.String? = null, parentId: kotlin.String? = null) : FileVM {
        val localVarResponse = exportFoldersGetOrCreateWithHttpInfo(name = name, subscriptionId = subscriptionId, parentId = parentId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FileVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get specified folder
     * User with a Get Entity permission can access this method.
     * @param name folder name (optional)
     * @param subscriptionId subscriptionId (optional)
     * @param parentId parent folder id (optional)
     * @return ApiResponse<FileVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun exportFoldersGetOrCreateWithHttpInfo(name: kotlin.String?, subscriptionId: kotlin.String?, parentId: kotlin.String?) : ApiResponse<FileVM?> {
        val localVariableConfig = exportFoldersGetOrCreateRequestConfig(name = name, subscriptionId = subscriptionId, parentId = parentId)

        return request<Unit, FileVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exportFoldersGetOrCreate
     *
     * @param name folder name (optional)
     * @param subscriptionId subscriptionId (optional)
     * @param parentId parent folder id (optional)
     * @return RequestConfig
     */
    fun exportFoldersGetOrCreateRequestConfig(name: kotlin.String?, subscriptionId: kotlin.String?, parentId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (subscriptionId != null) {
                    put("subscriptionId", listOf(subscriptionId.toString()))
                }
                if (parentId != null) {
                    put("parentId", listOf(parentId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/rp/v1/Exports/Folder/getOrCreate",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get all folder permissions
     * 
     * @param id 
     * @return FilePermissionsVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exportFoldersGetPermissions(id: kotlin.String) : FilePermissionsVM {
        val localVarResponse = exportFoldersGetPermissionsWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FilePermissionsVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get all folder permissions
     * 
     * @param id 
     * @return ApiResponse<FilePermissionsVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun exportFoldersGetPermissionsWithHttpInfo(id: kotlin.String) : ApiResponse<FilePermissionsVM?> {
        val localVariableConfig = exportFoldersGetPermissionsRequestConfig(id = id)

        return request<Unit, FilePermissionsVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exportFoldersGetPermissions
     *
     * @param id 
     * @return RequestConfig
     */
    fun exportFoldersGetPermissionsRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/rp/v1/Exports/Folder/{id}/permissions".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get user&#39;s root folder (without parents)
     * &gt; Breakchange. Now user model doesn&#39;t contain a root folders.  This method can return error 400 and 404 when subscription is not found.
     * @param subscriptionId  (optional)
     * @return FileVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exportFoldersGetRootFolder(subscriptionId: kotlin.String? = null) : FileVM {
        val localVarResponse = exportFoldersGetRootFolderWithHttpInfo(subscriptionId = subscriptionId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FileVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get user&#39;s root folder (without parents)
     * &gt; Breakchange. Now user model doesn&#39;t contain a root folders.  This method can return error 400 and 404 when subscription is not found.
     * @param subscriptionId  (optional)
     * @return ApiResponse<FileVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun exportFoldersGetRootFolderWithHttpInfo(subscriptionId: kotlin.String?) : ApiResponse<FileVM?> {
        val localVariableConfig = exportFoldersGetRootFolderRequestConfig(subscriptionId = subscriptionId)

        return request<Unit, FileVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exportFoldersGetRootFolder
     *
     * @param subscriptionId  (optional)
     * @return RequestConfig
     */
    fun exportFoldersGetRootFolderRequestConfig(subscriptionId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (subscriptionId != null) {
                    put("subscriptionId", listOf(subscriptionId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/rp/v1/Exports/Root",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Move folder to a specified folder
     * User with a Update Place permission for a folder and Create Entity  for a Parent Folder can access this method.
     * @param id moving folder id
     * @param folderId destination folder id
     * @return FileVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exportFoldersMoveFolder(id: kotlin.String, folderId: kotlin.String) : FileVM {
        val localVarResponse = exportFoldersMoveFolderWithHttpInfo(id = id, folderId = folderId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FileVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Move folder to a specified folder
     * User with a Update Place permission for a folder and Create Entity  for a Parent Folder can access this method.
     * @param id moving folder id
     * @param folderId destination folder id
     * @return ApiResponse<FileVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun exportFoldersMoveFolderWithHttpInfo(id: kotlin.String, folderId: kotlin.String) : ApiResponse<FileVM?> {
        val localVariableConfig = exportFoldersMoveFolderRequestConfig(id = id, folderId = folderId)

        return request<Unit, FileVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exportFoldersMoveFolder
     *
     * @param id moving folder id
     * @param folderId destination folder id
     * @return RequestConfig
     */
    fun exportFoldersMoveFolderRequestConfig(id: kotlin.String, folderId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/rp/v1/Exports/Folder/{id}/Move/{folderId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"folderId"+"}", encodeURIComponent(folderId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Move specified folder to recycle bin
     * User with a Delete Entity permission can access this method.
     * @param id folder id
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exportFoldersMoveFolderToBin(id: kotlin.String) : Unit {
        val localVarResponse = exportFoldersMoveFolderToBinWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Move specified folder to recycle bin
     * User with a Delete Entity permission can access this method.
     * @param id folder id
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun exportFoldersMoveFolderToBinWithHttpInfo(id: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = exportFoldersMoveFolderToBinRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exportFoldersMoveFolderToBin
     *
     * @param id folder id
     * @return RequestConfig
     */
    fun exportFoldersMoveFolderToBinRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/rp/v1/Exports/Folder/{id}/ToBin".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Create folder
     * User with a Create Entity permisison can access this method.
     * @param id Identifier of parent folder id
     * @param exportFolderCreateVM create VM (optional)
     * @return FileVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exportFoldersPostFolder(id: kotlin.String, exportFolderCreateVM: ExportFolderCreateVM? = null) : FileVM {
        val localVarResponse = exportFoldersPostFolderWithHttpInfo(id = id, exportFolderCreateVM = exportFolderCreateVM)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FileVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create folder
     * User with a Create Entity permisison can access this method.
     * @param id Identifier of parent folder id
     * @param exportFolderCreateVM create VM (optional)
     * @return ApiResponse<FileVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun exportFoldersPostFolderWithHttpInfo(id: kotlin.String, exportFolderCreateVM: ExportFolderCreateVM?) : ApiResponse<FileVM?> {
        val localVariableConfig = exportFoldersPostFolderRequestConfig(id = id, exportFolderCreateVM = exportFolderCreateVM)

        return request<ExportFolderCreateVM, FileVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exportFoldersPostFolder
     *
     * @param id Identifier of parent folder id
     * @param exportFolderCreateVM create VM (optional)
     * @return RequestConfig
     */
    fun exportFoldersPostFolderRequestConfig(id: kotlin.String, exportFolderCreateVM: ExportFolderCreateVM?) : RequestConfig<ExportFolderCreateVM> {
        val localVariableBody = exportFolderCreateVM
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/rp/v1/Exports/Folder/{id}/Folder".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Recover specified folder
     * User with a Delete Entity permission can access this method.
     * @param id folder id
     * @param recoveryPath  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exportFoldersRecoverFolder(id: kotlin.String, recoveryPath: kotlin.String? = null) : Unit {
        val localVarResponse = exportFoldersRecoverFolderWithHttpInfo(id = id, recoveryPath = recoveryPath)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Recover specified folder
     * User with a Delete Entity permission can access this method.
     * @param id folder id
     * @param recoveryPath  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun exportFoldersRecoverFolderWithHttpInfo(id: kotlin.String, recoveryPath: kotlin.String?) : ApiResponse<Unit?> {
        val localVariableConfig = exportFoldersRecoverFolderRequestConfig(id = id, recoveryPath = recoveryPath)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exportFoldersRecoverFolder
     *
     * @param id folder id
     * @param recoveryPath  (optional)
     * @return RequestConfig
     */
    fun exportFoldersRecoverFolderRequestConfig(id: kotlin.String, recoveryPath: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (recoveryPath != null) {
                    put("recoveryPath", listOf(recoveryPath.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/rp/v1/Exports/Folder/{id}/Recover".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Rename a folder
     * User with a Update Name permision can access this method.
     * @param id 
     * @param folderRenameVM  (optional)
     * @return FileVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exportFoldersRenameFolder(id: kotlin.String, folderRenameVM: FolderRenameVM? = null) : FileVM {
        val localVarResponse = exportFoldersRenameFolderWithHttpInfo(id = id, folderRenameVM = folderRenameVM)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FileVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Rename a folder
     * User with a Update Name permision can access this method.
     * @param id 
     * @param folderRenameVM  (optional)
     * @return ApiResponse<FileVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun exportFoldersRenameFolderWithHttpInfo(id: kotlin.String, folderRenameVM: FolderRenameVM?) : ApiResponse<FileVM?> {
        val localVariableConfig = exportFoldersRenameFolderRequestConfig(id = id, folderRenameVM = folderRenameVM)

        return request<FolderRenameVM, FileVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exportFoldersRenameFolder
     *
     * @param id 
     * @param folderRenameVM  (optional)
     * @return RequestConfig
     */
    fun exportFoldersRenameFolderRequestConfig(id: kotlin.String, folderRenameVM: FolderRenameVM?) : RequestConfig<FolderRenameVM> {
        val localVariableBody = folderRenameVM
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/rp/v1/Exports/Folder/{id}/Rename".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Update a folder&#39;s icon
     * User with a Update Icon permission can access this method.
     * @param id Identifier of folder
     * @param folderIconVM Update icon model (optional)
     * @return FileVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exportFoldersUpdateIcon(id: kotlin.String, folderIconVM: FolderIconVM? = null) : FileVM {
        val localVarResponse = exportFoldersUpdateIconWithHttpInfo(id = id, folderIconVM = folderIconVM)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FileVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update a folder&#39;s icon
     * User with a Update Icon permission can access this method.
     * @param id Identifier of folder
     * @param folderIconVM Update icon model (optional)
     * @return ApiResponse<FileVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun exportFoldersUpdateIconWithHttpInfo(id: kotlin.String, folderIconVM: FolderIconVM?) : ApiResponse<FileVM?> {
        val localVariableConfig = exportFoldersUpdateIconRequestConfig(id = id, folderIconVM = folderIconVM)

        return request<FolderIconVM, FileVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exportFoldersUpdateIcon
     *
     * @param id Identifier of folder
     * @param folderIconVM Update icon model (optional)
     * @return RequestConfig
     */
    fun exportFoldersUpdateIconRequestConfig(id: kotlin.String, folderIconVM: FolderIconVM?) : RequestConfig<FolderIconVM> {
        val localVariableBody = folderIconVM
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/rp/v1/Exports/Folder/{id}/Icon".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Update permissions
     * 
     * @param id 
     * @param updateFilePermissionsVM  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exportFoldersUpdatePermissions(id: kotlin.String, updateFilePermissionsVM: UpdateFilePermissionsVM? = null) : Unit {
        val localVarResponse = exportFoldersUpdatePermissionsWithHttpInfo(id = id, updateFilePermissionsVM = updateFilePermissionsVM)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update permissions
     * 
     * @param id 
     * @param updateFilePermissionsVM  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun exportFoldersUpdatePermissionsWithHttpInfo(id: kotlin.String, updateFilePermissionsVM: UpdateFilePermissionsVM?) : ApiResponse<Unit?> {
        val localVariableConfig = exportFoldersUpdatePermissionsRequestConfig(id = id, updateFilePermissionsVM = updateFilePermissionsVM)

        return request<UpdateFilePermissionsVM, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exportFoldersUpdatePermissions
     *
     * @param id 
     * @param updateFilePermissionsVM  (optional)
     * @return RequestConfig
     */
    fun exportFoldersUpdatePermissionsRequestConfig(id: kotlin.String, updateFilePermissionsVM: UpdateFilePermissionsVM?) : RequestConfig<UpdateFilePermissionsVM> {
        val localVariableBody = updateFilePermissionsVM
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/rp/v1/Exports/{id}/permissions".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Update tags
     * User with a Update Tags permission can access this method.
     * @param id 
     * @param folderTagsUpdateVM  (optional)
     * @return FileVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exportFoldersUpdateTags(id: kotlin.String, folderTagsUpdateVM: FolderTagsUpdateVM? = null) : FileVM {
        val localVarResponse = exportFoldersUpdateTagsWithHttpInfo(id = id, folderTagsUpdateVM = folderTagsUpdateVM)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FileVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update tags
     * User with a Update Tags permission can access this method.
     * @param id 
     * @param folderTagsUpdateVM  (optional)
     * @return ApiResponse<FileVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun exportFoldersUpdateTagsWithHttpInfo(id: kotlin.String, folderTagsUpdateVM: FolderTagsUpdateVM?) : ApiResponse<FileVM?> {
        val localVariableConfig = exportFoldersUpdateTagsRequestConfig(id = id, folderTagsUpdateVM = folderTagsUpdateVM)

        return request<FolderTagsUpdateVM, FileVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exportFoldersUpdateTags
     *
     * @param id 
     * @param folderTagsUpdateVM  (optional)
     * @return RequestConfig
     */
    fun exportFoldersUpdateTagsRequestConfig(id: kotlin.String, folderTagsUpdateVM: FolderTagsUpdateVM?) : RequestConfig<FolderTagsUpdateVM> {
        val localVariableBody = folderTagsUpdateVM
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/rp/v1/Exports/Folder/{id}/UpdateTags".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Copy file to a specified folder
     * 
     * @param id file id
     * @param folderId folder id
     * @return ExportVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exportsCopyFile(id: kotlin.String, folderId: kotlin.String) : ExportVM {
        val localVarResponse = exportsCopyFileWithHttpInfo(id = id, folderId = folderId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ExportVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Copy file to a specified folder
     * 
     * @param id file id
     * @param folderId folder id
     * @return ApiResponse<ExportVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun exportsCopyFileWithHttpInfo(id: kotlin.String, folderId: kotlin.String) : ApiResponse<ExportVM?> {
        val localVariableConfig = exportsCopyFileRequestConfig(id = id, folderId = folderId)

        return request<Unit, ExportVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exportsCopyFile
     *
     * @param id file id
     * @param folderId folder id
     * @return RequestConfig
     */
    fun exportsCopyFileRequestConfig(id: kotlin.String, folderId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/rp/v1/Exports/File/{id}/Copy/{folderId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"folderId"+"}", encodeURIComponent(folderId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Create a new key, that can be used to share access to a file  (You need Administrate.Anon permission to create a new key)
     * 
     * @param id file id
     * @param createFileShareVM parameters for sharing key creation (optional)
     * @return FileSharingKeysVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exportsCreateSharingKey(id: kotlin.String, createFileShareVM: CreateFileShareVM? = null) : FileSharingKeysVM {
        val localVarResponse = exportsCreateSharingKeyWithHttpInfo(id = id, createFileShareVM = createFileShareVM)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FileSharingKeysVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create a new key, that can be used to share access to a file  (You need Administrate.Anon permission to create a new key)
     * 
     * @param id file id
     * @param createFileShareVM parameters for sharing key creation (optional)
     * @return ApiResponse<FileSharingKeysVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun exportsCreateSharingKeyWithHttpInfo(id: kotlin.String, createFileShareVM: CreateFileShareVM?) : ApiResponse<FileSharingKeysVM?> {
        val localVariableConfig = exportsCreateSharingKeyRequestConfig(id = id, createFileShareVM = createFileShareVM)

        return request<CreateFileShareVM, FileSharingKeysVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exportsCreateSharingKey
     *
     * @param id file id
     * @param createFileShareVM parameters for sharing key creation (optional)
     * @return RequestConfig
     */
    fun exportsCreateSharingKeyRequestConfig(id: kotlin.String, createFileShareVM: CreateFileShareVM?) : RequestConfig<CreateFileShareVM> {
        val localVariableBody = createFileShareVM
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/rp/v1/Exports/File/{id}/sharingKey".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Delete specified file
     * User with Delete permission can access the method.
     * @param id file id
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exportsDeleteFile(id: kotlin.String) : Unit {
        val localVarResponse = exportsDeleteFileWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete specified file
     * User with Delete permission can access the method.
     * @param id file id
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun exportsDeleteFileWithHttpInfo(id: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = exportsDeleteFileRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exportsDeleteFile
     *
     * @param id file id
     * @return RequestConfig
     */
    fun exportsDeleteFileRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/rp/v1/Exports/File/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Deletes a sharing key, making links, that utilizing it no longer work
     * 
     * @param id file id
     * @param key key to delete
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exportsDeleteSharingKey(id: kotlin.String, key: kotlin.String) : Unit {
        val localVarResponse = exportsDeleteSharingKeyWithHttpInfo(id = id, key = key)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Deletes a sharing key, making links, that utilizing it no longer work
     * 
     * @param id file id
     * @param key key to delete
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun exportsDeleteSharingKeyWithHttpInfo(id: kotlin.String, key: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = exportsDeleteSharingKeyRequestConfig(id = id, key = key)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exportsDeleteSharingKey
     *
     * @param id file id
     * @param key key to delete
     * @return RequestConfig
     */
    fun exportsDeleteSharingKeyRequestConfig(id: kotlin.String, key: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/rp/v1/Exports/File/{id}/sharingKey".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"key"+"}", encodeURIComponent(key.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get export by specified id
     * 
     * @param id id of export
     * @return ExportVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exportsGetFile(id: kotlin.String) : ExportVM {
        val localVarResponse = exportsGetFileWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ExportVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get export by specified id
     * 
     * @param id id of export
     * @return ApiResponse<ExportVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun exportsGetFileWithHttpInfo(id: kotlin.String) : ApiResponse<ExportVM?> {
        val localVariableConfig = exportsGetFileRequestConfig(id = id)

        return request<Unit, ExportVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exportsGetFile
     *
     * @param id id of export
     * @return RequestConfig
     */
    fun exportsGetFileRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/rp/v1/Exports/File/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Returns list of actions, performed on this file
     * 
     * @param id 
     * @param skip  (optional, default to 0)
     * @param take  (optional, default to 10)
     * @return AuditActionsVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exportsGetFileHistory(id: kotlin.String, skip: kotlin.Int? = 0, take: kotlin.Int? = 10) : AuditActionsVM {
        val localVarResponse = exportsGetFileHistoryWithHttpInfo(id = id, skip = skip, take = take)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AuditActionsVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Returns list of actions, performed on this file
     * 
     * @param id 
     * @param skip  (optional, default to 0)
     * @param take  (optional, default to 10)
     * @return ApiResponse<AuditActionsVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun exportsGetFileHistoryWithHttpInfo(id: kotlin.String, skip: kotlin.Int?, take: kotlin.Int?) : ApiResponse<AuditActionsVM?> {
        val localVariableConfig = exportsGetFileHistoryRequestConfig(id = id, skip = skip, take = take)

        return request<Unit, AuditActionsVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exportsGetFileHistory
     *
     * @param id 
     * @param skip  (optional, default to 0)
     * @param take  (optional, default to 10)
     * @return RequestConfig
     */
    fun exportsGetFileHistoryRequestConfig(id: kotlin.String, skip: kotlin.Int?, take: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (skip != null) {
                    put("skip", listOf(skip.toString()))
                }
                if (take != null) {
                    put("take", listOf(take.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/rp/v1/Exports/File/{id}/History".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get count of files what contains in a specified folder
     * User with Get Count permission can access this method.
     * @param id folder id
     * @return CountVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exportsGetFilesCount(id: kotlin.String) : CountVM {
        val localVarResponse = exportsGetFilesCountWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CountVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get count of files what contains in a specified folder
     * User with Get Count permission can access this method.
     * @param id folder id
     * @return ApiResponse<CountVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun exportsGetFilesCountWithHttpInfo(id: kotlin.String) : ApiResponse<CountVM?> {
        val localVariableConfig = exportsGetFilesCountRequestConfig(id = id)

        return request<Unit, CountVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exportsGetFilesCount
     *
     * @param id folder id
     * @return RequestConfig
     */
    fun exportsGetFilesCountRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/rp/v1/Exports/Folder/{id}/CountFiles".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get all files from specified folder. &lt;br /&gt;  User with Get Entity permission can access this method. &lt;br /&gt;  The method will returns minimal infomration about the file: &lt;br /&gt;  id, name, size, editedTime, createdTime, tags, status, statusReason.
     * 
     * @param id folder id
     * @param skip number of files, that have to be skipped (optional, default to 0)
     * @param take number of files, that have to be returned (optional, default to 10)
     * @param searchPattern  (optional)
     * @param orderBy  (optional)
     * @param desc  (optional, default to false)
     * @param useRegex  (optional, default to false)
     * @return ExportsVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exportsGetFilesList(id: kotlin.String, skip: kotlin.Int? = 0, take: kotlin.Int? = 10, searchPattern: kotlin.String? = null, orderBy: FileSorting? = null, desc: kotlin.Boolean? = false, useRegex: kotlin.Boolean? = false) : ExportsVM {
        val localVarResponse = exportsGetFilesListWithHttpInfo(id = id, skip = skip, take = take, searchPattern = searchPattern, orderBy = orderBy, desc = desc, useRegex = useRegex)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ExportsVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get all files from specified folder. &lt;br /&gt;  User with Get Entity permission can access this method. &lt;br /&gt;  The method will returns minimal infomration about the file: &lt;br /&gt;  id, name, size, editedTime, createdTime, tags, status, statusReason.
     * 
     * @param id folder id
     * @param skip number of files, that have to be skipped (optional, default to 0)
     * @param take number of files, that have to be returned (optional, default to 10)
     * @param searchPattern  (optional)
     * @param orderBy  (optional)
     * @param desc  (optional, default to false)
     * @param useRegex  (optional, default to false)
     * @return ApiResponse<ExportsVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun exportsGetFilesListWithHttpInfo(id: kotlin.String, skip: kotlin.Int?, take: kotlin.Int?, searchPattern: kotlin.String?, orderBy: FileSorting?, desc: kotlin.Boolean?, useRegex: kotlin.Boolean?) : ApiResponse<ExportsVM?> {
        val localVariableConfig = exportsGetFilesListRequestConfig(id = id, skip = skip, take = take, searchPattern = searchPattern, orderBy = orderBy, desc = desc, useRegex = useRegex)

        return request<Unit, ExportsVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exportsGetFilesList
     *
     * @param id folder id
     * @param skip number of files, that have to be skipped (optional, default to 0)
     * @param take number of files, that have to be returned (optional, default to 10)
     * @param searchPattern  (optional)
     * @param orderBy  (optional)
     * @param desc  (optional, default to false)
     * @param useRegex  (optional, default to false)
     * @return RequestConfig
     */
    fun exportsGetFilesListRequestConfig(id: kotlin.String, skip: kotlin.Int?, take: kotlin.Int?, searchPattern: kotlin.String?, orderBy: FileSorting?, desc: kotlin.Boolean?, useRegex: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (skip != null) {
                    put("skip", listOf(skip.toString()))
                }
                if (take != null) {
                    put("take", listOf(take.toString()))
                }
                if (searchPattern != null) {
                    put("searchPattern", listOf(searchPattern.toString()))
                }
                if (orderBy != null) {
                    put("orderBy", listOf(orderBy.toString()))
                }
                if (desc != null) {
                    put("desc", listOf(desc.toString()))
                }
                if (useRegex != null) {
                    put("useRegex", listOf(useRegex.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/rp/v1/Exports/Folder/{id}/ListFiles".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @return FilePermissionsVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exportsGetPermissions(id: kotlin.String) : FilePermissionsVM {
        val localVarResponse = exportsGetPermissionsWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FilePermissionsVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @return ApiResponse<FilePermissionsVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun exportsGetPermissionsWithHttpInfo(id: kotlin.String) : ApiResponse<FilePermissionsVM?> {
        val localVariableConfig = exportsGetPermissionsRequestConfig(id = id)

        return request<Unit, FilePermissionsVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exportsGetPermissions
     *
     * @param id 
     * @return RequestConfig
     */
    fun exportsGetPermissionsRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/rp/v1/Exports/File/{id}/permissions".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Returns all sharing keys, associated with the file
     * 
     * @param id file id
     * @return FileSharingKeysVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exportsGetSharingKeys(id: kotlin.String) : FileSharingKeysVM {
        val localVarResponse = exportsGetSharingKeysWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FileSharingKeysVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Returns all sharing keys, associated with the file
     * 
     * @param id file id
     * @return ApiResponse<FileSharingKeysVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun exportsGetSharingKeysWithHttpInfo(id: kotlin.String) : ApiResponse<FileSharingKeysVM?> {
        val localVariableConfig = exportsGetSharingKeysRequestConfig(id = id)

        return request<Unit, FileSharingKeysVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exportsGetSharingKeys
     *
     * @param id file id
     * @return RequestConfig
     */
    fun exportsGetSharingKeysRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/rp/v1/Exports/File/{id}/sharingKeys".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Move file to a specified folder
     * User with a Update Place permission for a folder and Create Entity  for a Parent Folder can access this method.
     * @param id file id
     * @param folderId folder id
     * @return ExportVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exportsMoveFile(id: kotlin.String, folderId: kotlin.String) : ExportVM {
        val localVarResponse = exportsMoveFileWithHttpInfo(id = id, folderId = folderId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ExportVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Move file to a specified folder
     * User with a Update Place permission for a folder and Create Entity  for a Parent Folder can access this method.
     * @param id file id
     * @param folderId folder id
     * @return ApiResponse<ExportVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun exportsMoveFileWithHttpInfo(id: kotlin.String, folderId: kotlin.String) : ApiResponse<ExportVM?> {
        val localVariableConfig = exportsMoveFileRequestConfig(id = id, folderId = folderId)

        return request<Unit, ExportVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exportsMoveFile
     *
     * @param id file id
     * @param folderId folder id
     * @return RequestConfig
     */
    fun exportsMoveFileRequestConfig(id: kotlin.String, folderId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/rp/v1/Exports/File/{id}/Move/{folderId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"folderId"+"}", encodeURIComponent(folderId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Move specified file to recycle bin
     * User with Delete permission can access the method.
     * @param id file id
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exportsMoveFileToBin(id: kotlin.String) : Unit {
        val localVarResponse = exportsMoveFileToBinWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Move specified file to recycle bin
     * User with Delete permission can access the method.
     * @param id file id
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun exportsMoveFileToBinWithHttpInfo(id: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = exportsMoveFileToBinRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exportsMoveFileToBin
     *
     * @param id file id
     * @return RequestConfig
     */
    fun exportsMoveFileToBinRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/rp/v1/Exports/File/{id}/ToBin".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Recover specified file from bin
     * User with Delete permission can access the method.
     * @param id file id
     * @param recoveryPath  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exportsRecoverFile(id: kotlin.String, recoveryPath: kotlin.String? = null) : Unit {
        val localVarResponse = exportsRecoverFileWithHttpInfo(id = id, recoveryPath = recoveryPath)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Recover specified file from bin
     * User with Delete permission can access the method.
     * @param id file id
     * @param recoveryPath  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun exportsRecoverFileWithHttpInfo(id: kotlin.String, recoveryPath: kotlin.String?) : ApiResponse<Unit?> {
        val localVariableConfig = exportsRecoverFileRequestConfig(id = id, recoveryPath = recoveryPath)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exportsRecoverFile
     *
     * @param id file id
     * @param recoveryPath  (optional)
     * @return RequestConfig
     */
    fun exportsRecoverFileRequestConfig(id: kotlin.String, recoveryPath: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (recoveryPath != null) {
                    put("recoveryPath", listOf(recoveryPath.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/rp/v1/Exports/File/{id}/Recover".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Rename a file
     * User with Update Name permission can access this method.
     * @param id 
     * @param fileRenameVM  (optional)
     * @return ExportVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exportsRenameFile(id: kotlin.String, fileRenameVM: FileRenameVM? = null) : ExportVM {
        val localVarResponse = exportsRenameFileWithHttpInfo(id = id, fileRenameVM = fileRenameVM)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ExportVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Rename a file
     * User with Update Name permission can access this method.
     * @param id 
     * @param fileRenameVM  (optional)
     * @return ApiResponse<ExportVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun exportsRenameFileWithHttpInfo(id: kotlin.String, fileRenameVM: FileRenameVM?) : ApiResponse<ExportVM?> {
        val localVariableConfig = exportsRenameFileRequestConfig(id = id, fileRenameVM = fileRenameVM)

        return request<FileRenameVM, ExportVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exportsRenameFile
     *
     * @param id 
     * @param fileRenameVM  (optional)
     * @return RequestConfig
     */
    fun exportsRenameFileRequestConfig(id: kotlin.String, fileRenameVM: FileRenameVM?) : RequestConfig<FileRenameVM> {
        val localVariableBody = fileRenameVM
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/rp/v1/Exports/File/{id}/Rename".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Update a files&#39;s icon
     * User with Update Icon permission can access this method.
     * @param id 
     * @param fileIconVM  (optional)
     * @return ExportVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exportsUpdateIcon(id: kotlin.String, fileIconVM: FileIconVM? = null) : ExportVM {
        val localVarResponse = exportsUpdateIconWithHttpInfo(id = id, fileIconVM = fileIconVM)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ExportVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update a files&#39;s icon
     * User with Update Icon permission can access this method.
     * @param id 
     * @param fileIconVM  (optional)
     * @return ApiResponse<ExportVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun exportsUpdateIconWithHttpInfo(id: kotlin.String, fileIconVM: FileIconVM?) : ApiResponse<ExportVM?> {
        val localVariableConfig = exportsUpdateIconRequestConfig(id = id, fileIconVM = fileIconVM)

        return request<FileIconVM, ExportVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exportsUpdateIcon
     *
     * @param id 
     * @param fileIconVM  (optional)
     * @return RequestConfig
     */
    fun exportsUpdateIconRequestConfig(id: kotlin.String, fileIconVM: FileIconVM?) : RequestConfig<FileIconVM> {
        val localVariableBody = fileIconVM
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/rp/v1/Exports/File/{id}/Icon".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Update permissions
     * 
     * @param id 
     * @param updateFilePermissionsVM  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exportsUpdatePermissions(id: kotlin.String, updateFilePermissionsVM: UpdateFilePermissionsVM? = null) : Unit {
        val localVarResponse = exportsUpdatePermissionsWithHttpInfo(id = id, updateFilePermissionsVM = updateFilePermissionsVM)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update permissions
     * 
     * @param id 
     * @param updateFilePermissionsVM  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun exportsUpdatePermissionsWithHttpInfo(id: kotlin.String, updateFilePermissionsVM: UpdateFilePermissionsVM?) : ApiResponse<Unit?> {
        val localVariableConfig = exportsUpdatePermissionsRequestConfig(id = id, updateFilePermissionsVM = updateFilePermissionsVM)

        return request<UpdateFilePermissionsVM, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exportsUpdatePermissions
     *
     * @param id 
     * @param updateFilePermissionsVM  (optional)
     * @return RequestConfig
     */
    fun exportsUpdatePermissionsRequestConfig(id: kotlin.String, updateFilePermissionsVM: UpdateFilePermissionsVM?) : RequestConfig<UpdateFilePermissionsVM> {
        val localVariableBody = updateFilePermissionsVM
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/rp/v1/Exports/File/{id}/permissions".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Update tags
     * User with Update Tags permission can access this method.
     * @param id 
     * @param fileTagsUpdateVM  (optional)
     * @return ExportVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exportsUpdateTags(id: kotlin.String, fileTagsUpdateVM: FileTagsUpdateVM? = null) : ExportVM {
        val localVarResponse = exportsUpdateTagsWithHttpInfo(id = id, fileTagsUpdateVM = fileTagsUpdateVM)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ExportVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update tags
     * User with Update Tags permission can access this method.
     * @param id 
     * @param fileTagsUpdateVM  (optional)
     * @return ApiResponse<ExportVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun exportsUpdateTagsWithHttpInfo(id: kotlin.String, fileTagsUpdateVM: FileTagsUpdateVM?) : ApiResponse<ExportVM?> {
        val localVariableConfig = exportsUpdateTagsRequestConfig(id = id, fileTagsUpdateVM = fileTagsUpdateVM)

        return request<FileTagsUpdateVM, ExportVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation exportsUpdateTags
     *
     * @param id 
     * @param fileTagsUpdateVM  (optional)
     * @return RequestConfig
     */
    fun exportsUpdateTagsRequestConfig(id: kotlin.String, fileTagsUpdateVM: FileTagsUpdateVM?) : RequestConfig<FileTagsUpdateVM> {
        val localVariableBody = fileTagsUpdateVM
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/rp/v1/Exports/File/{id}/UpdateTags".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
