/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package cloud.fastreport.client

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import cloud.fastreport.model.AuditActionsVM
import cloud.fastreport.model.BreadcrumbsVM
import cloud.fastreport.model.CountVM
import cloud.fastreport.model.ExportTemplateVM
import cloud.fastreport.model.ExportVM
import cloud.fastreport.model.FileIconVM
import cloud.fastreport.model.FilePermissionsVM
import cloud.fastreport.model.FileRenameVM
import cloud.fastreport.model.FileSorting
import cloud.fastreport.model.FileTagsUpdateVM
import cloud.fastreport.model.FileVM
import cloud.fastreport.model.FilesVM
import cloud.fastreport.model.FolderIconVM
import cloud.fastreport.model.FolderRenameVM
import cloud.fastreport.model.FolderSizeVM
import cloud.fastreport.model.FolderTagsUpdateVM
import cloud.fastreport.model.PrepareTemplateVM
import cloud.fastreport.model.PreviewTemplateVM
import cloud.fastreport.model.ProblemDetails
import cloud.fastreport.model.ReportVM
import cloud.fastreport.model.SelectedFilesVM
import cloud.fastreport.model.TemplateCreateVM
import cloud.fastreport.model.TemplateFolderCreateVM
import cloud.fastreport.model.TemplateVM
import cloud.fastreport.model.TemplatesVM
import cloud.fastreport.model.UpdateFileContentVM
import cloud.fastreport.model.UpdateFilePermissionsVM

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class TemplatesApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
     * Delete all folders and files from recycle bin
     * User with a Delete RecycleBin permission can access this method.
     * @param subscriptionId subscription id
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templateFolderAndFileClearRecycleBin(subscriptionId: kotlin.String) : Unit {
        val localVarResponse = templateFolderAndFileClearRecycleBinWithHttpInfo(subscriptionId = subscriptionId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete all folders and files from recycle bin
     * User with a Delete RecycleBin permission can access this method.
     * @param subscriptionId subscription id
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun templateFolderAndFileClearRecycleBinWithHttpInfo(subscriptionId: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = templateFolderAndFileClearRecycleBinRequestConfig(subscriptionId = subscriptionId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templateFolderAndFileClearRecycleBin
     *
     * @param subscriptionId subscription id
     * @return RequestConfig
     */
    fun templateFolderAndFileClearRecycleBinRequestConfig(subscriptionId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/rp/v1/Templates/{subscriptionId}/ClearRecycleBin".replace("{"+"subscriptionId"+"}", encodeURIComponent(subscriptionId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Copy folders and files to a specified folder
     * User with a Get permission for a files and Create permission for a destination folder can access this method.
     * @param subscriptionId id of current subscription
     * @param selectedFilesVM VM with files&#39; ids and params of their destination (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templateFolderAndFileCopyFiles(subscriptionId: kotlin.String, selectedFilesVM: SelectedFilesVM? = null) : Unit {
        val localVarResponse = templateFolderAndFileCopyFilesWithHttpInfo(subscriptionId = subscriptionId, selectedFilesVM = selectedFilesVM)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Copy folders and files to a specified folder
     * User with a Get permission for a files and Create permission for a destination folder can access this method.
     * @param subscriptionId id of current subscription
     * @param selectedFilesVM VM with files&#39; ids and params of their destination (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun templateFolderAndFileCopyFilesWithHttpInfo(subscriptionId: kotlin.String, selectedFilesVM: SelectedFilesVM?) : ApiResponse<Unit?> {
        val localVariableConfig = templateFolderAndFileCopyFilesRequestConfig(subscriptionId = subscriptionId, selectedFilesVM = selectedFilesVM)

        return request<SelectedFilesVM, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templateFolderAndFileCopyFiles
     *
     * @param subscriptionId id of current subscription
     * @param selectedFilesVM VM with files&#39; ids and params of their destination (optional)
     * @return RequestConfig
     */
    fun templateFolderAndFileCopyFilesRequestConfig(subscriptionId: kotlin.String, selectedFilesVM: SelectedFilesVM?) : RequestConfig<SelectedFilesVM> {
        val localVariableBody = selectedFilesVM
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/rp/v1/Templates/{subscriptionId}/CopyFiles".replace("{"+"subscriptionId"+"}", encodeURIComponent(subscriptionId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Delete folders and files
     * User with a Delete permission can access this method.
     * @param subscriptionId id of current subscription
     * @param selectedFilesVM VM with files&#39; ids and params of their destination (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templateFolderAndFileDeleteFiles(subscriptionId: kotlin.String, selectedFilesVM: SelectedFilesVM? = null) : Unit {
        val localVarResponse = templateFolderAndFileDeleteFilesWithHttpInfo(subscriptionId = subscriptionId, selectedFilesVM = selectedFilesVM)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete folders and files
     * User with a Delete permission can access this method.
     * @param subscriptionId id of current subscription
     * @param selectedFilesVM VM with files&#39; ids and params of their destination (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun templateFolderAndFileDeleteFilesWithHttpInfo(subscriptionId: kotlin.String, selectedFilesVM: SelectedFilesVM?) : ApiResponse<Unit?> {
        val localVariableConfig = templateFolderAndFileDeleteFilesRequestConfig(subscriptionId = subscriptionId, selectedFilesVM = selectedFilesVM)

        return request<SelectedFilesVM, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templateFolderAndFileDeleteFiles
     *
     * @param subscriptionId id of current subscription
     * @param selectedFilesVM VM with files&#39; ids and params of their destination (optional)
     * @return RequestConfig
     */
    fun templateFolderAndFileDeleteFilesRequestConfig(subscriptionId: kotlin.String, selectedFilesVM: SelectedFilesVM?) : RequestConfig<SelectedFilesVM> {
        val localVariableBody = selectedFilesVM
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/rp/v1/Templates/{subscriptionId}/DeleteFiles".replace("{"+"subscriptionId"+"}", encodeURIComponent(subscriptionId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get count of files and folders what contains in a specified folder
     * User with a Get Count permission can access this method.
     * @param id folder id
     * @param searchPattern string, that must be incuded in file or folder name to be counted &lt;br /&gt;              (leave undefined to count all files and folders) (optional)
     * @param useRegex set this to true if you want to use regular expression to search (optional, default to false)
     * @return CountVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templateFolderAndFileGetCount(id: kotlin.String, searchPattern: kotlin.String? = null, useRegex: kotlin.Boolean? = false) : CountVM {
        val localVarResponse = templateFolderAndFileGetCountWithHttpInfo(id = id, searchPattern = searchPattern, useRegex = useRegex)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CountVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get count of files and folders what contains in a specified folder
     * User with a Get Count permission can access this method.
     * @param id folder id
     * @param searchPattern string, that must be incuded in file or folder name to be counted &lt;br /&gt;              (leave undefined to count all files and folders) (optional)
     * @param useRegex set this to true if you want to use regular expression to search (optional, default to false)
     * @return ApiResponse<CountVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun templateFolderAndFileGetCountWithHttpInfo(id: kotlin.String, searchPattern: kotlin.String?, useRegex: kotlin.Boolean?) : ApiResponse<CountVM?> {
        val localVariableConfig = templateFolderAndFileGetCountRequestConfig(id = id, searchPattern = searchPattern, useRegex = useRegex)

        return request<Unit, CountVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templateFolderAndFileGetCount
     *
     * @param id folder id
     * @param searchPattern string, that must be incuded in file or folder name to be counted &lt;br /&gt;              (leave undefined to count all files and folders) (optional)
     * @param useRegex set this to true if you want to use regular expression to search (optional, default to false)
     * @return RequestConfig
     */
    fun templateFolderAndFileGetCountRequestConfig(id: kotlin.String, searchPattern: kotlin.String?, useRegex: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (searchPattern != null) {
                    put("searchPattern", listOf(searchPattern.toString()))
                }
                if (useRegex != null) {
                    put("useRegex", listOf(useRegex.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/rp/v1/Templates/Folder/{id}/CountFolderAndFiles".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get all folders and files from specified folder
     * User with a Get Entity permission can access this method.
     * @param id folder id
     * @param skip number of folder and files, that have to be skipped (optional, default to 0)
     * @param take number of folder and files, that have to be returned (optional, default to 10)
     * @param orderBy indicates a field to sort by (optional)
     * @param desc indicates if sorting is descending (optional, default to false)
     * @param searchPattern  (optional, default to "")
     * @param useRegex  (optional, default to false)
     * @return FilesVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templateFolderAndFileGetFoldersAndFiles(id: kotlin.String, skip: kotlin.Int? = 0, take: kotlin.Int? = 10, orderBy: FileSorting? = null, desc: kotlin.Boolean? = false, searchPattern: kotlin.String? = "", useRegex: kotlin.Boolean? = false) : FilesVM {
        val localVarResponse = templateFolderAndFileGetFoldersAndFilesWithHttpInfo(id = id, skip = skip, take = take, orderBy = orderBy, desc = desc, searchPattern = searchPattern, useRegex = useRegex)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FilesVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get all folders and files from specified folder
     * User with a Get Entity permission can access this method.
     * @param id folder id
     * @param skip number of folder and files, that have to be skipped (optional, default to 0)
     * @param take number of folder and files, that have to be returned (optional, default to 10)
     * @param orderBy indicates a field to sort by (optional)
     * @param desc indicates if sorting is descending (optional, default to false)
     * @param searchPattern  (optional, default to "")
     * @param useRegex  (optional, default to false)
     * @return ApiResponse<FilesVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun templateFolderAndFileGetFoldersAndFilesWithHttpInfo(id: kotlin.String, skip: kotlin.Int?, take: kotlin.Int?, orderBy: FileSorting?, desc: kotlin.Boolean?, searchPattern: kotlin.String?, useRegex: kotlin.Boolean?) : ApiResponse<FilesVM?> {
        val localVariableConfig = templateFolderAndFileGetFoldersAndFilesRequestConfig(id = id, skip = skip, take = take, orderBy = orderBy, desc = desc, searchPattern = searchPattern, useRegex = useRegex)

        return request<Unit, FilesVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templateFolderAndFileGetFoldersAndFiles
     *
     * @param id folder id
     * @param skip number of folder and files, that have to be skipped (optional, default to 0)
     * @param take number of folder and files, that have to be returned (optional, default to 10)
     * @param orderBy indicates a field to sort by (optional)
     * @param desc indicates if sorting is descending (optional, default to false)
     * @param searchPattern  (optional, default to "")
     * @param useRegex  (optional, default to false)
     * @return RequestConfig
     */
    fun templateFolderAndFileGetFoldersAndFilesRequestConfig(id: kotlin.String, skip: kotlin.Int?, take: kotlin.Int?, orderBy: FileSorting?, desc: kotlin.Boolean?, searchPattern: kotlin.String?, useRegex: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (skip != null) {
                    put("skip", listOf(skip.toString()))
                }
                if (take != null) {
                    put("take", listOf(take.toString()))
                }
                if (orderBy != null) {
                    put("orderBy", listOf(orderBy.toString()))
                }
                if (desc != null) {
                    put("desc", listOf(desc.toString()))
                }
                if (searchPattern != null) {
                    put("searchPattern", listOf(searchPattern.toString()))
                }
                if (useRegex != null) {
                    put("useRegex", listOf(useRegex.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/rp/v1/Templates/Folder/{id}/ListFolderAndFiles".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get all folders and files from recycle bin
     * User with a Get DeletedFiles permission can access this method.
     * @param subscriptionId subscription id
     * @param skip number of folder and files, that have to be skipped (optional, default to 0)
     * @param take number of folder and files, that have to be returned (optional, default to 10)
     * @param orderBy indicates a field to sort by (optional)
     * @param desc indicates if sorting is descending (optional, default to false)
     * @param searchPattern  (optional, default to "")
     * @param useRegex  (optional, default to false)
     * @return FilesVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templateFolderAndFileGetRecycleBinFoldersAndFiles(subscriptionId: kotlin.String, skip: kotlin.Int? = 0, take: kotlin.Int? = 10, orderBy: FileSorting? = null, desc: kotlin.Boolean? = false, searchPattern: kotlin.String? = "", useRegex: kotlin.Boolean? = false) : FilesVM {
        val localVarResponse = templateFolderAndFileGetRecycleBinFoldersAndFilesWithHttpInfo(subscriptionId = subscriptionId, skip = skip, take = take, orderBy = orderBy, desc = desc, searchPattern = searchPattern, useRegex = useRegex)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FilesVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get all folders and files from recycle bin
     * User with a Get DeletedFiles permission can access this method.
     * @param subscriptionId subscription id
     * @param skip number of folder and files, that have to be skipped (optional, default to 0)
     * @param take number of folder and files, that have to be returned (optional, default to 10)
     * @param orderBy indicates a field to sort by (optional)
     * @param desc indicates if sorting is descending (optional, default to false)
     * @param searchPattern  (optional, default to "")
     * @param useRegex  (optional, default to false)
     * @return ApiResponse<FilesVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun templateFolderAndFileGetRecycleBinFoldersAndFilesWithHttpInfo(subscriptionId: kotlin.String, skip: kotlin.Int?, take: kotlin.Int?, orderBy: FileSorting?, desc: kotlin.Boolean?, searchPattern: kotlin.String?, useRegex: kotlin.Boolean?) : ApiResponse<FilesVM?> {
        val localVariableConfig = templateFolderAndFileGetRecycleBinFoldersAndFilesRequestConfig(subscriptionId = subscriptionId, skip = skip, take = take, orderBy = orderBy, desc = desc, searchPattern = searchPattern, useRegex = useRegex)

        return request<Unit, FilesVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templateFolderAndFileGetRecycleBinFoldersAndFiles
     *
     * @param subscriptionId subscription id
     * @param skip number of folder and files, that have to be skipped (optional, default to 0)
     * @param take number of folder and files, that have to be returned (optional, default to 10)
     * @param orderBy indicates a field to sort by (optional)
     * @param desc indicates if sorting is descending (optional, default to false)
     * @param searchPattern  (optional, default to "")
     * @param useRegex  (optional, default to false)
     * @return RequestConfig
     */
    fun templateFolderAndFileGetRecycleBinFoldersAndFilesRequestConfig(subscriptionId: kotlin.String, skip: kotlin.Int?, take: kotlin.Int?, orderBy: FileSorting?, desc: kotlin.Boolean?, searchPattern: kotlin.String?, useRegex: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (skip != null) {
                    put("skip", listOf(skip.toString()))
                }
                if (take != null) {
                    put("take", listOf(take.toString()))
                }
                if (orderBy != null) {
                    put("orderBy", listOf(orderBy.toString()))
                }
                if (desc != null) {
                    put("desc", listOf(desc.toString()))
                }
                if (searchPattern != null) {
                    put("searchPattern", listOf(searchPattern.toString()))
                }
                if (useRegex != null) {
                    put("useRegex", listOf(useRegex.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/rp/v1/Templates/{subscriptionId}/ListRecycleBinFolderAndFiles".replace("{"+"subscriptionId"+"}", encodeURIComponent(subscriptionId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Move folders and files to a specified folder
     * User with a Update Place permission for a files and Create permission for a destination folder can access this method.
     * @param subscriptionId id of current subscription
     * @param selectedFilesVM VM with files&#39; ids and params of their destination (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templateFolderAndFileMoveFiles(subscriptionId: kotlin.String, selectedFilesVM: SelectedFilesVM? = null) : Unit {
        val localVarResponse = templateFolderAndFileMoveFilesWithHttpInfo(subscriptionId = subscriptionId, selectedFilesVM = selectedFilesVM)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Move folders and files to a specified folder
     * User with a Update Place permission for a files and Create permission for a destination folder can access this method.
     * @param subscriptionId id of current subscription
     * @param selectedFilesVM VM with files&#39; ids and params of their destination (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun templateFolderAndFileMoveFilesWithHttpInfo(subscriptionId: kotlin.String, selectedFilesVM: SelectedFilesVM?) : ApiResponse<Unit?> {
        val localVariableConfig = templateFolderAndFileMoveFilesRequestConfig(subscriptionId = subscriptionId, selectedFilesVM = selectedFilesVM)

        return request<SelectedFilesVM, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templateFolderAndFileMoveFiles
     *
     * @param subscriptionId id of current subscription
     * @param selectedFilesVM VM with files&#39; ids and params of their destination (optional)
     * @return RequestConfig
     */
    fun templateFolderAndFileMoveFilesRequestConfig(subscriptionId: kotlin.String, selectedFilesVM: SelectedFilesVM?) : RequestConfig<SelectedFilesVM> {
        val localVariableBody = selectedFilesVM
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/rp/v1/Templates/{subscriptionId}/MoveFiles".replace("{"+"subscriptionId"+"}", encodeURIComponent(subscriptionId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Move folders and files to bin
     * User with a Delete permission can access this method.
     * @param subscriptionId id of current subscription
     * @param selectedFilesVM VM with files&#39; ids and params of their destination (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templateFolderAndFileMoveFilesToBin(subscriptionId: kotlin.String, selectedFilesVM: SelectedFilesVM? = null) : Unit {
        val localVarResponse = templateFolderAndFileMoveFilesToBinWithHttpInfo(subscriptionId = subscriptionId, selectedFilesVM = selectedFilesVM)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Move folders and files to bin
     * User with a Delete permission can access this method.
     * @param subscriptionId id of current subscription
     * @param selectedFilesVM VM with files&#39; ids and params of their destination (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun templateFolderAndFileMoveFilesToBinWithHttpInfo(subscriptionId: kotlin.String, selectedFilesVM: SelectedFilesVM?) : ApiResponse<Unit?> {
        val localVariableConfig = templateFolderAndFileMoveFilesToBinRequestConfig(subscriptionId = subscriptionId, selectedFilesVM = selectedFilesVM)

        return request<SelectedFilesVM, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templateFolderAndFileMoveFilesToBin
     *
     * @param subscriptionId id of current subscription
     * @param selectedFilesVM VM with files&#39; ids and params of their destination (optional)
     * @return RequestConfig
     */
    fun templateFolderAndFileMoveFilesToBinRequestConfig(subscriptionId: kotlin.String, selectedFilesVM: SelectedFilesVM?) : RequestConfig<SelectedFilesVM> {
        val localVariableBody = selectedFilesVM
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/rp/v1/Templates/{subscriptionId}/ToBin".replace("{"+"subscriptionId"+"}", encodeURIComponent(subscriptionId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Recover all folders and files from recycle bin
     * User with a Create RecycleBin permission can access this method.
     * @param subscriptionId subscription id
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templateFolderAndFileRecoverAllFromRecycleBin(subscriptionId: kotlin.String) : Unit {
        val localVarResponse = templateFolderAndFileRecoverAllFromRecycleBinWithHttpInfo(subscriptionId = subscriptionId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Recover all folders and files from recycle bin
     * User with a Create RecycleBin permission can access this method.
     * @param subscriptionId subscription id
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun templateFolderAndFileRecoverAllFromRecycleBinWithHttpInfo(subscriptionId: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = templateFolderAndFileRecoverAllFromRecycleBinRequestConfig(subscriptionId = subscriptionId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templateFolderAndFileRecoverAllFromRecycleBin
     *
     * @param subscriptionId subscription id
     * @return RequestConfig
     */
    fun templateFolderAndFileRecoverAllFromRecycleBinRequestConfig(subscriptionId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/rp/v1/Templates/{subscriptionId}/RecoverRecycleBin".replace("{"+"subscriptionId"+"}", encodeURIComponent(subscriptionId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Recover folders and files from bin
     * User with a SubscriptionCreate permission can access this method.
     * @param subscriptionId id of current subscription
     * @param selectedFilesVM VM with files&#39; ids and params of their destination (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templateFolderAndFileRecoverFiles(subscriptionId: kotlin.String, selectedFilesVM: SelectedFilesVM? = null) : Unit {
        val localVarResponse = templateFolderAndFileRecoverFilesWithHttpInfo(subscriptionId = subscriptionId, selectedFilesVM = selectedFilesVM)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Recover folders and files from bin
     * User with a SubscriptionCreate permission can access this method.
     * @param subscriptionId id of current subscription
     * @param selectedFilesVM VM with files&#39; ids and params of their destination (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun templateFolderAndFileRecoverFilesWithHttpInfo(subscriptionId: kotlin.String, selectedFilesVM: SelectedFilesVM?) : ApiResponse<Unit?> {
        val localVariableConfig = templateFolderAndFileRecoverFilesRequestConfig(subscriptionId = subscriptionId, selectedFilesVM = selectedFilesVM)

        return request<SelectedFilesVM, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templateFolderAndFileRecoverFiles
     *
     * @param subscriptionId id of current subscription
     * @param selectedFilesVM VM with files&#39; ids and params of their destination (optional)
     * @return RequestConfig
     */
    fun templateFolderAndFileRecoverFilesRequestConfig(subscriptionId: kotlin.String, selectedFilesVM: SelectedFilesVM?) : RequestConfig<SelectedFilesVM> {
        val localVariableBody = selectedFilesVM
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/rp/v1/Templates/{subscriptionId}/RecoverFiles".replace("{"+"subscriptionId"+"}", encodeURIComponent(subscriptionId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get specified folder, calculate it&#39;s size
     * User with a Get Entity permission can access this method.
     * @param id folder id
     * @return FolderSizeVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templateFoldersCalculateFolderSize(id: kotlin.String) : FolderSizeVM {
        val localVarResponse = templateFoldersCalculateFolderSizeWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FolderSizeVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get specified folder, calculate it&#39;s size
     * User with a Get Entity permission can access this method.
     * @param id folder id
     * @return ApiResponse<FolderSizeVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun templateFoldersCalculateFolderSizeWithHttpInfo(id: kotlin.String) : ApiResponse<FolderSizeVM?> {
        val localVariableConfig = templateFoldersCalculateFolderSizeRequestConfig(id = id)

        return request<Unit, FolderSizeVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templateFoldersCalculateFolderSize
     *
     * @param id folder id
     * @return RequestConfig
     */
    fun templateFoldersCalculateFolderSizeRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/rp/v1/Templates/Folder/{id}/size".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Move folder to a specified folder
     * User with a Update Place permission for a folder and Create Entity  for a Parent Folder can access this method.
     * @param id moving folder id
     * @param folderId destination folder id
     * @return FileVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templateFoldersCopyFolder(id: kotlin.String, folderId: kotlin.String) : FileVM {
        val localVarResponse = templateFoldersCopyFolderWithHttpInfo(id = id, folderId = folderId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FileVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Move folder to a specified folder
     * User with a Update Place permission for a folder and Create Entity  for a Parent Folder can access this method.
     * @param id moving folder id
     * @param folderId destination folder id
     * @return ApiResponse<FileVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun templateFoldersCopyFolderWithHttpInfo(id: kotlin.String, folderId: kotlin.String) : ApiResponse<FileVM?> {
        val localVariableConfig = templateFoldersCopyFolderRequestConfig(id = id, folderId = folderId)

        return request<Unit, FileVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templateFoldersCopyFolder
     *
     * @param id moving folder id
     * @param folderId destination folder id
     * @return RequestConfig
     */
    fun templateFoldersCopyFolderRequestConfig(id: kotlin.String, folderId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/rp/v1/Templates/Folder/{id}/Copy/{folderId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"folderId"+"}", encodeURIComponent(folderId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Delete specified folder
     * User with a Delete Entity permission can access this method.
     * @param id folder id
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templateFoldersDeleteFolder(id: kotlin.String) : Unit {
        val localVarResponse = templateFoldersDeleteFolderWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete specified folder
     * User with a Delete Entity permission can access this method.
     * @param id folder id
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun templateFoldersDeleteFolderWithHttpInfo(id: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = templateFoldersDeleteFolderRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templateFoldersDeleteFolder
     *
     * @param id folder id
     * @return RequestConfig
     */
    fun templateFoldersDeleteFolderRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/rp/v1/Templates/Folder/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Export specified template folder to a specified format
     * User with Execute Export permission on template folder and  Create Entity on an export folder can access this method.
     * @param id template folder id
     * @param exportTemplateVM export parameters (string only) (optional)
     * @return FileVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templateFoldersExport(id: kotlin.String, exportTemplateVM: ExportTemplateVM? = null) : FileVM {
        val localVarResponse = templateFoldersExportWithHttpInfo(id = id, exportTemplateVM = exportTemplateVM)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FileVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Export specified template folder to a specified format
     * User with Execute Export permission on template folder and  Create Entity on an export folder can access this method.
     * @param id template folder id
     * @param exportTemplateVM export parameters (string only) (optional)
     * @return ApiResponse<FileVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun templateFoldersExportWithHttpInfo(id: kotlin.String, exportTemplateVM: ExportTemplateVM?) : ApiResponse<FileVM?> {
        val localVariableConfig = templateFoldersExportRequestConfig(id = id, exportTemplateVM = exportTemplateVM)

        return request<ExportTemplateVM, FileVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templateFoldersExport
     *
     * @param id template folder id
     * @param exportTemplateVM export parameters (string only) (optional)
     * @return RequestConfig
     */
    fun templateFoldersExportRequestConfig(id: kotlin.String, exportTemplateVM: ExportTemplateVM?) : RequestConfig<ExportTemplateVM> {
        val localVariableBody = exportTemplateVM
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/rp/v1/Templates/Folder/{id}/Export".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get specified folder breadcrumbs
     * User with a Get Entity permission can access this method.
     * @param id folder id
     * @return BreadcrumbsVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templateFoldersGetBreadcrumbs(id: kotlin.String) : BreadcrumbsVM {
        val localVarResponse = templateFoldersGetBreadcrumbsWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BreadcrumbsVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get specified folder breadcrumbs
     * User with a Get Entity permission can access this method.
     * @param id folder id
     * @return ApiResponse<BreadcrumbsVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun templateFoldersGetBreadcrumbsWithHttpInfo(id: kotlin.String) : ApiResponse<BreadcrumbsVM?> {
        val localVariableConfig = templateFoldersGetBreadcrumbsRequestConfig(id = id)

        return request<Unit, BreadcrumbsVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templateFoldersGetBreadcrumbs
     *
     * @param id folder id
     * @return RequestConfig
     */
    fun templateFoldersGetBreadcrumbsRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/rp/v1/Templates/Folder/{id}/Breadcrumbs".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get specified folder
     * User with a Get Entity permission can access this method.
     * @param id folder id
     * @return FileVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templateFoldersGetFolder(id: kotlin.String) : FileVM {
        val localVarResponse = templateFoldersGetFolderWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FileVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get specified folder
     * User with a Get Entity permission can access this method.
     * @param id folder id
     * @return ApiResponse<FileVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun templateFoldersGetFolderWithHttpInfo(id: kotlin.String) : ApiResponse<FileVM?> {
        val localVariableConfig = templateFoldersGetFolderRequestConfig(id = id)

        return request<Unit, FileVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templateFoldersGetFolder
     *
     * @param id folder id
     * @return RequestConfig
     */
    fun templateFoldersGetFolderRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/rp/v1/Templates/Folder/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get all folders from specified folder
     * User with a Get Entity permission can access this method.
     * @param id folder id
     * @param skip number of files, that have to be skipped (optional, default to 0)
     * @param take number of files, that have to be returned (optional, default to 10)
     * @param orderBy  (optional)
     * @param desc  (optional, default to false)
     * @param searchPattern  (optional, default to "")
     * @param useRegex  (optional, default to false)
     * @return FilesVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templateFoldersGetFolders(id: kotlin.String, skip: kotlin.Int? = 0, take: kotlin.Int? = 10, orderBy: FileSorting? = null, desc: kotlin.Boolean? = false, searchPattern: kotlin.String? = "", useRegex: kotlin.Boolean? = false) : FilesVM {
        val localVarResponse = templateFoldersGetFoldersWithHttpInfo(id = id, skip = skip, take = take, orderBy = orderBy, desc = desc, searchPattern = searchPattern, useRegex = useRegex)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FilesVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get all folders from specified folder
     * User with a Get Entity permission can access this method.
     * @param id folder id
     * @param skip number of files, that have to be skipped (optional, default to 0)
     * @param take number of files, that have to be returned (optional, default to 10)
     * @param orderBy  (optional)
     * @param desc  (optional, default to false)
     * @param searchPattern  (optional, default to "")
     * @param useRegex  (optional, default to false)
     * @return ApiResponse<FilesVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun templateFoldersGetFoldersWithHttpInfo(id: kotlin.String, skip: kotlin.Int?, take: kotlin.Int?, orderBy: FileSorting?, desc: kotlin.Boolean?, searchPattern: kotlin.String?, useRegex: kotlin.Boolean?) : ApiResponse<FilesVM?> {
        val localVariableConfig = templateFoldersGetFoldersRequestConfig(id = id, skip = skip, take = take, orderBy = orderBy, desc = desc, searchPattern = searchPattern, useRegex = useRegex)

        return request<Unit, FilesVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templateFoldersGetFolders
     *
     * @param id folder id
     * @param skip number of files, that have to be skipped (optional, default to 0)
     * @param take number of files, that have to be returned (optional, default to 10)
     * @param orderBy  (optional)
     * @param desc  (optional, default to false)
     * @param searchPattern  (optional, default to "")
     * @param useRegex  (optional, default to false)
     * @return RequestConfig
     */
    fun templateFoldersGetFoldersRequestConfig(id: kotlin.String, skip: kotlin.Int?, take: kotlin.Int?, orderBy: FileSorting?, desc: kotlin.Boolean?, searchPattern: kotlin.String?, useRegex: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (skip != null) {
                    put("skip", listOf(skip.toString()))
                }
                if (take != null) {
                    put("take", listOf(take.toString()))
                }
                if (orderBy != null) {
                    put("orderBy", listOf(orderBy.toString()))
                }
                if (desc != null) {
                    put("desc", listOf(desc.toString()))
                }
                if (searchPattern != null) {
                    put("searchPattern", listOf(searchPattern.toString()))
                }
                if (useRegex != null) {
                    put("useRegex", listOf(useRegex.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/rp/v1/Templates/Folder/{id}/ListFolders".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get count of folders what contains in a specified folder
     * User with a Get Count permission can access this method.
     * @param id folder id
     * @return CountVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templateFoldersGetFoldersCount(id: kotlin.String) : CountVM {
        val localVarResponse = templateFoldersGetFoldersCountWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CountVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get count of folders what contains in a specified folder
     * User with a Get Count permission can access this method.
     * @param id folder id
     * @return ApiResponse<CountVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun templateFoldersGetFoldersCountWithHttpInfo(id: kotlin.String) : ApiResponse<CountVM?> {
        val localVariableConfig = templateFoldersGetFoldersCountRequestConfig(id = id)

        return request<Unit, CountVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templateFoldersGetFoldersCount
     *
     * @param id folder id
     * @return RequestConfig
     */
    fun templateFoldersGetFoldersCountRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/rp/v1/Templates/Folder/{id}/CountFolders".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get specified folder
     * User with a Get Entity permission can access this method.
     * @param name folder name (optional)
     * @param subscriptionId subscriptionId (optional)
     * @param parentId parent folder id (optional)
     * @return FileVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templateFoldersGetOrCreate(name: kotlin.String? = null, subscriptionId: kotlin.String? = null, parentId: kotlin.String? = null) : FileVM {
        val localVarResponse = templateFoldersGetOrCreateWithHttpInfo(name = name, subscriptionId = subscriptionId, parentId = parentId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FileVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get specified folder
     * User with a Get Entity permission can access this method.
     * @param name folder name (optional)
     * @param subscriptionId subscriptionId (optional)
     * @param parentId parent folder id (optional)
     * @return ApiResponse<FileVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun templateFoldersGetOrCreateWithHttpInfo(name: kotlin.String?, subscriptionId: kotlin.String?, parentId: kotlin.String?) : ApiResponse<FileVM?> {
        val localVariableConfig = templateFoldersGetOrCreateRequestConfig(name = name, subscriptionId = subscriptionId, parentId = parentId)

        return request<Unit, FileVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templateFoldersGetOrCreate
     *
     * @param name folder name (optional)
     * @param subscriptionId subscriptionId (optional)
     * @param parentId parent folder id (optional)
     * @return RequestConfig
     */
    fun templateFoldersGetOrCreateRequestConfig(name: kotlin.String?, subscriptionId: kotlin.String?, parentId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (subscriptionId != null) {
                    put("subscriptionId", listOf(subscriptionId.toString()))
                }
                if (parentId != null) {
                    put("parentId", listOf(parentId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/rp/v1/Templates/Folder/getOrCreate",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get all folder permissions
     * 
     * @param id 
     * @return FilePermissionsVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templateFoldersGetPermissions(id: kotlin.String) : FilePermissionsVM {
        val localVarResponse = templateFoldersGetPermissionsWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FilePermissionsVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get all folder permissions
     * 
     * @param id 
     * @return ApiResponse<FilePermissionsVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun templateFoldersGetPermissionsWithHttpInfo(id: kotlin.String) : ApiResponse<FilePermissionsVM?> {
        val localVariableConfig = templateFoldersGetPermissionsRequestConfig(id = id)

        return request<Unit, FilePermissionsVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templateFoldersGetPermissions
     *
     * @param id 
     * @return RequestConfig
     */
    fun templateFoldersGetPermissionsRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/rp/v1/Templates/Folder/{id}/permissions".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get user&#39;s root folder (without parents)
     * &gt; Breakchange. Now user model doesn&#39;t contain a root folders.  This method can return error 400 and 404 when subscription is not found.
     * @param subscriptionId  (optional)
     * @return FileVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templateFoldersGetRootFolder(subscriptionId: kotlin.String? = null) : FileVM {
        val localVarResponse = templateFoldersGetRootFolderWithHttpInfo(subscriptionId = subscriptionId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FileVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get user&#39;s root folder (without parents)
     * &gt; Breakchange. Now user model doesn&#39;t contain a root folders.  This method can return error 400 and 404 when subscription is not found.
     * @param subscriptionId  (optional)
     * @return ApiResponse<FileVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun templateFoldersGetRootFolderWithHttpInfo(subscriptionId: kotlin.String?) : ApiResponse<FileVM?> {
        val localVariableConfig = templateFoldersGetRootFolderRequestConfig(subscriptionId = subscriptionId)

        return request<Unit, FileVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templateFoldersGetRootFolder
     *
     * @param subscriptionId  (optional)
     * @return RequestConfig
     */
    fun templateFoldersGetRootFolderRequestConfig(subscriptionId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (subscriptionId != null) {
                    put("subscriptionId", listOf(subscriptionId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/rp/v1/Templates/Root",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Move folder to a specified folder
     * User with a Update Place permission for a folder and Create Entity  for a Parent Folder can access this method.
     * @param id moving folder id
     * @param folderId destination folder id
     * @return FileVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templateFoldersMoveFolder(id: kotlin.String, folderId: kotlin.String) : FileVM {
        val localVarResponse = templateFoldersMoveFolderWithHttpInfo(id = id, folderId = folderId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FileVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Move folder to a specified folder
     * User with a Update Place permission for a folder and Create Entity  for a Parent Folder can access this method.
     * @param id moving folder id
     * @param folderId destination folder id
     * @return ApiResponse<FileVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun templateFoldersMoveFolderWithHttpInfo(id: kotlin.String, folderId: kotlin.String) : ApiResponse<FileVM?> {
        val localVariableConfig = templateFoldersMoveFolderRequestConfig(id = id, folderId = folderId)

        return request<Unit, FileVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templateFoldersMoveFolder
     *
     * @param id moving folder id
     * @param folderId destination folder id
     * @return RequestConfig
     */
    fun templateFoldersMoveFolderRequestConfig(id: kotlin.String, folderId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/rp/v1/Templates/Folder/{id}/Move/{folderId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"folderId"+"}", encodeURIComponent(folderId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Move specified folder to recycle bin
     * User with a Delete Entity permission can access this method.
     * @param id folder id
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templateFoldersMoveFolderToBin(id: kotlin.String) : Unit {
        val localVarResponse = templateFoldersMoveFolderToBinWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Move specified folder to recycle bin
     * User with a Delete Entity permission can access this method.
     * @param id folder id
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun templateFoldersMoveFolderToBinWithHttpInfo(id: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = templateFoldersMoveFolderToBinRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templateFoldersMoveFolderToBin
     *
     * @param id folder id
     * @return RequestConfig
     */
    fun templateFoldersMoveFolderToBinRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/rp/v1/Templates/Folder/{id}/ToBin".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Create folder
     * User with a Create Entity permisison can access this method.
     * @param id Identifier of parent folder id
     * @param templateFolderCreateVM create VM (optional)
     * @return FileVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templateFoldersPostFolder(id: kotlin.String, templateFolderCreateVM: TemplateFolderCreateVM? = null) : FileVM {
        val localVarResponse = templateFoldersPostFolderWithHttpInfo(id = id, templateFolderCreateVM = templateFolderCreateVM)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FileVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create folder
     * User with a Create Entity permisison can access this method.
     * @param id Identifier of parent folder id
     * @param templateFolderCreateVM create VM (optional)
     * @return ApiResponse<FileVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun templateFoldersPostFolderWithHttpInfo(id: kotlin.String, templateFolderCreateVM: TemplateFolderCreateVM?) : ApiResponse<FileVM?> {
        val localVariableConfig = templateFoldersPostFolderRequestConfig(id = id, templateFolderCreateVM = templateFolderCreateVM)

        return request<TemplateFolderCreateVM, FileVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templateFoldersPostFolder
     *
     * @param id Identifier of parent folder id
     * @param templateFolderCreateVM create VM (optional)
     * @return RequestConfig
     */
    fun templateFoldersPostFolderRequestConfig(id: kotlin.String, templateFolderCreateVM: TemplateFolderCreateVM?) : RequestConfig<TemplateFolderCreateVM> {
        val localVariableBody = templateFolderCreateVM
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/rp/v1/Templates/Folder/{id}/Folder".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Prepare specified template folder to report folder
     * User with Execute Prepare permission on report and  Create Entity on a prepared report folder can access this method.
     * @param id template id
     * @param prepareTemplateVM Template folder prepare view model (optional)
     * @return FileVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templateFoldersPrepare(id: kotlin.String, prepareTemplateVM: PrepareTemplateVM? = null) : FileVM {
        val localVarResponse = templateFoldersPrepareWithHttpInfo(id = id, prepareTemplateVM = prepareTemplateVM)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FileVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Prepare specified template folder to report folder
     * User with Execute Prepare permission on report and  Create Entity on a prepared report folder can access this method.
     * @param id template id
     * @param prepareTemplateVM Template folder prepare view model (optional)
     * @return ApiResponse<FileVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun templateFoldersPrepareWithHttpInfo(id: kotlin.String, prepareTemplateVM: PrepareTemplateVM?) : ApiResponse<FileVM?> {
        val localVariableConfig = templateFoldersPrepareRequestConfig(id = id, prepareTemplateVM = prepareTemplateVM)

        return request<PrepareTemplateVM, FileVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templateFoldersPrepare
     *
     * @param id template id
     * @param prepareTemplateVM Template folder prepare view model (optional)
     * @return RequestConfig
     */
    fun templateFoldersPrepareRequestConfig(id: kotlin.String, prepareTemplateVM: PrepareTemplateVM?) : RequestConfig<PrepareTemplateVM> {
        val localVariableBody = prepareTemplateVM
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/rp/v1/Templates/Folder/{id}/Prepare".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Recover specified folder
     * User with a Delete Entity permission can access this method.
     * @param id folder id
     * @param recoveryPath  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templateFoldersRecoverFolder(id: kotlin.String, recoveryPath: kotlin.String? = null) : Unit {
        val localVarResponse = templateFoldersRecoverFolderWithHttpInfo(id = id, recoveryPath = recoveryPath)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Recover specified folder
     * User with a Delete Entity permission can access this method.
     * @param id folder id
     * @param recoveryPath  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun templateFoldersRecoverFolderWithHttpInfo(id: kotlin.String, recoveryPath: kotlin.String?) : ApiResponse<Unit?> {
        val localVariableConfig = templateFoldersRecoverFolderRequestConfig(id = id, recoveryPath = recoveryPath)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templateFoldersRecoverFolder
     *
     * @param id folder id
     * @param recoveryPath  (optional)
     * @return RequestConfig
     */
    fun templateFoldersRecoverFolderRequestConfig(id: kotlin.String, recoveryPath: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (recoveryPath != null) {
                    put("recoveryPath", listOf(recoveryPath.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/rp/v1/Templates/Folder/{id}/Recover".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Rename a folder
     * User with a Update Name permision can access this method.
     * @param id 
     * @param folderRenameVM  (optional)
     * @return FileVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templateFoldersRenameFolder(id: kotlin.String, folderRenameVM: FolderRenameVM? = null) : FileVM {
        val localVarResponse = templateFoldersRenameFolderWithHttpInfo(id = id, folderRenameVM = folderRenameVM)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FileVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Rename a folder
     * User with a Update Name permision can access this method.
     * @param id 
     * @param folderRenameVM  (optional)
     * @return ApiResponse<FileVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun templateFoldersRenameFolderWithHttpInfo(id: kotlin.String, folderRenameVM: FolderRenameVM?) : ApiResponse<FileVM?> {
        val localVariableConfig = templateFoldersRenameFolderRequestConfig(id = id, folderRenameVM = folderRenameVM)

        return request<FolderRenameVM, FileVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templateFoldersRenameFolder
     *
     * @param id 
     * @param folderRenameVM  (optional)
     * @return RequestConfig
     */
    fun templateFoldersRenameFolderRequestConfig(id: kotlin.String, folderRenameVM: FolderRenameVM?) : RequestConfig<FolderRenameVM> {
        val localVariableBody = folderRenameVM
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/rp/v1/Templates/Folder/{id}/Rename".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Update a folder&#39;s icon
     * User with a Update Icon permission can access this method.
     * @param id Identifier of folder
     * @param folderIconVM Update icon model (optional)
     * @return FileVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templateFoldersUpdateIcon(id: kotlin.String, folderIconVM: FolderIconVM? = null) : FileVM {
        val localVarResponse = templateFoldersUpdateIconWithHttpInfo(id = id, folderIconVM = folderIconVM)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FileVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update a folder&#39;s icon
     * User with a Update Icon permission can access this method.
     * @param id Identifier of folder
     * @param folderIconVM Update icon model (optional)
     * @return ApiResponse<FileVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun templateFoldersUpdateIconWithHttpInfo(id: kotlin.String, folderIconVM: FolderIconVM?) : ApiResponse<FileVM?> {
        val localVariableConfig = templateFoldersUpdateIconRequestConfig(id = id, folderIconVM = folderIconVM)

        return request<FolderIconVM, FileVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templateFoldersUpdateIcon
     *
     * @param id Identifier of folder
     * @param folderIconVM Update icon model (optional)
     * @return RequestConfig
     */
    fun templateFoldersUpdateIconRequestConfig(id: kotlin.String, folderIconVM: FolderIconVM?) : RequestConfig<FolderIconVM> {
        val localVariableBody = folderIconVM
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/rp/v1/Templates/Folder/{id}/Icon".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Update permissions
     * 
     * @param id 
     * @param updateFilePermissionsVM  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templateFoldersUpdatePermissions(id: kotlin.String, updateFilePermissionsVM: UpdateFilePermissionsVM? = null) : Unit {
        val localVarResponse = templateFoldersUpdatePermissionsWithHttpInfo(id = id, updateFilePermissionsVM = updateFilePermissionsVM)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update permissions
     * 
     * @param id 
     * @param updateFilePermissionsVM  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun templateFoldersUpdatePermissionsWithHttpInfo(id: kotlin.String, updateFilePermissionsVM: UpdateFilePermissionsVM?) : ApiResponse<Unit?> {
        val localVariableConfig = templateFoldersUpdatePermissionsRequestConfig(id = id, updateFilePermissionsVM = updateFilePermissionsVM)

        return request<UpdateFilePermissionsVM, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templateFoldersUpdatePermissions
     *
     * @param id 
     * @param updateFilePermissionsVM  (optional)
     * @return RequestConfig
     */
    fun templateFoldersUpdatePermissionsRequestConfig(id: kotlin.String, updateFilePermissionsVM: UpdateFilePermissionsVM?) : RequestConfig<UpdateFilePermissionsVM> {
        val localVariableBody = updateFilePermissionsVM
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/rp/v1/Templates/{id}/permissions".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Update tags
     * User with a Update Tags permission can access this method.
     * @param id 
     * @param folderTagsUpdateVM  (optional)
     * @return FileVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templateFoldersUpdateTags(id: kotlin.String, folderTagsUpdateVM: FolderTagsUpdateVM? = null) : FileVM {
        val localVarResponse = templateFoldersUpdateTagsWithHttpInfo(id = id, folderTagsUpdateVM = folderTagsUpdateVM)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FileVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update tags
     * User with a Update Tags permission can access this method.
     * @param id 
     * @param folderTagsUpdateVM  (optional)
     * @return ApiResponse<FileVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun templateFoldersUpdateTagsWithHttpInfo(id: kotlin.String, folderTagsUpdateVM: FolderTagsUpdateVM?) : ApiResponse<FileVM?> {
        val localVariableConfig = templateFoldersUpdateTagsRequestConfig(id = id, folderTagsUpdateVM = folderTagsUpdateVM)

        return request<FolderTagsUpdateVM, FileVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templateFoldersUpdateTags
     *
     * @param id 
     * @param folderTagsUpdateVM  (optional)
     * @return RequestConfig
     */
    fun templateFoldersUpdateTagsRequestConfig(id: kotlin.String, folderTagsUpdateVM: FolderTagsUpdateVM?) : RequestConfig<FolderTagsUpdateVM> {
        val localVariableBody = folderTagsUpdateVM
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/rp/v1/Templates/Folder/{id}/UpdateTags".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Copy file to a specified folder
     * 
     * @param id file id
     * @param folderId folder id
     * @return TemplateVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templatesCopyFile(id: kotlin.String, folderId: kotlin.String) : TemplateVM {
        val localVarResponse = templatesCopyFileWithHttpInfo(id = id, folderId = folderId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TemplateVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Copy file to a specified folder
     * 
     * @param id file id
     * @param folderId folder id
     * @return ApiResponse<TemplateVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun templatesCopyFileWithHttpInfo(id: kotlin.String, folderId: kotlin.String) : ApiResponse<TemplateVM?> {
        val localVariableConfig = templatesCopyFileRequestConfig(id = id, folderId = folderId)

        return request<Unit, TemplateVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templatesCopyFile
     *
     * @param id file id
     * @param folderId folder id
     * @return RequestConfig
     */
    fun templatesCopyFileRequestConfig(id: kotlin.String, folderId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/rp/v1/Templates/File/{id}/Copy/{folderId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"folderId"+"}", encodeURIComponent(folderId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Delete specified file
     * User with Delete permission can access the method.
     * @param id file id
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templatesDeleteFile(id: kotlin.String) : Unit {
        val localVarResponse = templatesDeleteFileWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete specified file
     * User with Delete permission can access the method.
     * @param id file id
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun templatesDeleteFileWithHttpInfo(id: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = templatesDeleteFileRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templatesDeleteFile
     *
     * @param id file id
     * @return RequestConfig
     */
    fun templatesDeleteFileRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/rp/v1/Templates/File/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Export specified report template to a specified format
     * User with Execute Export permission on prepared report and  Create Entity on an export folder can access this method.
     * @param id template id
     * @param exportTemplateVM export parameters (string only) (optional)
     * @return ExportVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templatesExport(id: kotlin.String, exportTemplateVM: ExportTemplateVM? = null) : ExportVM {
        val localVarResponse = templatesExportWithHttpInfo(id = id, exportTemplateVM = exportTemplateVM)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ExportVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Export specified report template to a specified format
     * User with Execute Export permission on prepared report and  Create Entity on an export folder can access this method.
     * @param id template id
     * @param exportTemplateVM export parameters (string only) (optional)
     * @return ApiResponse<ExportVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun templatesExportWithHttpInfo(id: kotlin.String, exportTemplateVM: ExportTemplateVM?) : ApiResponse<ExportVM?> {
        val localVariableConfig = templatesExportRequestConfig(id = id, exportTemplateVM = exportTemplateVM)

        return request<ExportTemplateVM, ExportVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templatesExport
     *
     * @param id template id
     * @param exportTemplateVM export parameters (string only) (optional)
     * @return RequestConfig
     */
    fun templatesExportRequestConfig(id: kotlin.String, exportTemplateVM: ExportTemplateVM?) : RequestConfig<ExportTemplateVM> {
        val localVariableBody = exportTemplateVM
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/rp/v1/Templates/File/{id}/Export".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get specified file
     * User with Get Entity permission can access this method.
     * @param id file id
     * @return TemplateVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templatesGetFile(id: kotlin.String) : TemplateVM {
        val localVarResponse = templatesGetFileWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TemplateVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get specified file
     * User with Get Entity permission can access this method.
     * @param id file id
     * @return ApiResponse<TemplateVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun templatesGetFileWithHttpInfo(id: kotlin.String) : ApiResponse<TemplateVM?> {
        val localVariableConfig = templatesGetFileRequestConfig(id = id)

        return request<Unit, TemplateVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templatesGetFile
     *
     * @param id file id
     * @return RequestConfig
     */
    fun templatesGetFileRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/rp/v1/Templates/File/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Returns list of actions, performed on this file
     * 
     * @param id 
     * @param skip  (optional, default to 0)
     * @param take  (optional, default to 10)
     * @return AuditActionsVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templatesGetFileHistory(id: kotlin.String, skip: kotlin.Int? = 0, take: kotlin.Int? = 10) : AuditActionsVM {
        val localVarResponse = templatesGetFileHistoryWithHttpInfo(id = id, skip = skip, take = take)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AuditActionsVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Returns list of actions, performed on this file
     * 
     * @param id 
     * @param skip  (optional, default to 0)
     * @param take  (optional, default to 10)
     * @return ApiResponse<AuditActionsVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun templatesGetFileHistoryWithHttpInfo(id: kotlin.String, skip: kotlin.Int?, take: kotlin.Int?) : ApiResponse<AuditActionsVM?> {
        val localVariableConfig = templatesGetFileHistoryRequestConfig(id = id, skip = skip, take = take)

        return request<Unit, AuditActionsVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templatesGetFileHistory
     *
     * @param id 
     * @param skip  (optional, default to 0)
     * @param take  (optional, default to 10)
     * @return RequestConfig
     */
    fun templatesGetFileHistoryRequestConfig(id: kotlin.String, skip: kotlin.Int?, take: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (skip != null) {
                    put("skip", listOf(skip.toString()))
                }
                if (take != null) {
                    put("take", listOf(take.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/rp/v1/Templates/File/{id}/History".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get count of files what contains in a specified folder
     * User with Get Count permission can access this method.
     * @param id folder id
     * @return CountVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templatesGetFilesCount(id: kotlin.String) : CountVM {
        val localVarResponse = templatesGetFilesCountWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CountVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get count of files what contains in a specified folder
     * User with Get Count permission can access this method.
     * @param id folder id
     * @return ApiResponse<CountVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun templatesGetFilesCountWithHttpInfo(id: kotlin.String) : ApiResponse<CountVM?> {
        val localVariableConfig = templatesGetFilesCountRequestConfig(id = id)

        return request<Unit, CountVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templatesGetFilesCount
     *
     * @param id folder id
     * @return RequestConfig
     */
    fun templatesGetFilesCountRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/rp/v1/Templates/Folder/{id}/CountFiles".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get all files from specified folder. &lt;br /&gt;  User with Get Entity permission can access this method. &lt;br /&gt;  The method will returns minimal infomration about the file: &lt;br /&gt;  id, name, size, editedTime, createdTime, tags, status, statusReason.
     * 
     * @param id folder id
     * @param skip number of files, that have to be skipped (optional, default to 0)
     * @param take number of files, that have to be returned (optional, default to 10)
     * @param searchPattern  (optional)
     * @param orderBy  (optional)
     * @param desc  (optional, default to false)
     * @param useRegex  (optional, default to false)
     * @return TemplatesVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templatesGetFilesList(id: kotlin.String, skip: kotlin.Int? = 0, take: kotlin.Int? = 10, searchPattern: kotlin.String? = null, orderBy: FileSorting? = null, desc: kotlin.Boolean? = false, useRegex: kotlin.Boolean? = false) : TemplatesVM {
        val localVarResponse = templatesGetFilesListWithHttpInfo(id = id, skip = skip, take = take, searchPattern = searchPattern, orderBy = orderBy, desc = desc, useRegex = useRegex)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TemplatesVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get all files from specified folder. &lt;br /&gt;  User with Get Entity permission can access this method. &lt;br /&gt;  The method will returns minimal infomration about the file: &lt;br /&gt;  id, name, size, editedTime, createdTime, tags, status, statusReason.
     * 
     * @param id folder id
     * @param skip number of files, that have to be skipped (optional, default to 0)
     * @param take number of files, that have to be returned (optional, default to 10)
     * @param searchPattern  (optional)
     * @param orderBy  (optional)
     * @param desc  (optional, default to false)
     * @param useRegex  (optional, default to false)
     * @return ApiResponse<TemplatesVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun templatesGetFilesListWithHttpInfo(id: kotlin.String, skip: kotlin.Int?, take: kotlin.Int?, searchPattern: kotlin.String?, orderBy: FileSorting?, desc: kotlin.Boolean?, useRegex: kotlin.Boolean?) : ApiResponse<TemplatesVM?> {
        val localVariableConfig = templatesGetFilesListRequestConfig(id = id, skip = skip, take = take, searchPattern = searchPattern, orderBy = orderBy, desc = desc, useRegex = useRegex)

        return request<Unit, TemplatesVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templatesGetFilesList
     *
     * @param id folder id
     * @param skip number of files, that have to be skipped (optional, default to 0)
     * @param take number of files, that have to be returned (optional, default to 10)
     * @param searchPattern  (optional)
     * @param orderBy  (optional)
     * @param desc  (optional, default to false)
     * @param useRegex  (optional, default to false)
     * @return RequestConfig
     */
    fun templatesGetFilesListRequestConfig(id: kotlin.String, skip: kotlin.Int?, take: kotlin.Int?, searchPattern: kotlin.String?, orderBy: FileSorting?, desc: kotlin.Boolean?, useRegex: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (skip != null) {
                    put("skip", listOf(skip.toString()))
                }
                if (take != null) {
                    put("take", listOf(take.toString()))
                }
                if (searchPattern != null) {
                    put("searchPattern", listOf(searchPattern.toString()))
                }
                if (orderBy != null) {
                    put("orderBy", listOf(orderBy.toString()))
                }
                if (desc != null) {
                    put("desc", listOf(desc.toString()))
                }
                if (useRegex != null) {
                    put("useRegex", listOf(useRegex.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/rp/v1/Templates/Folder/{id}/ListFiles".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @return FilePermissionsVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templatesGetPermissions(id: kotlin.String) : FilePermissionsVM {
        val localVarResponse = templatesGetPermissionsWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FilePermissionsVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @return ApiResponse<FilePermissionsVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun templatesGetPermissionsWithHttpInfo(id: kotlin.String) : ApiResponse<FilePermissionsVM?> {
        val localVariableConfig = templatesGetPermissionsRequestConfig(id = id)

        return request<Unit, FilePermissionsVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templatesGetPermissions
     *
     * @param id 
     * @return RequestConfig
     */
    fun templatesGetPermissionsRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/rp/v1/Templates/File/{id}/permissions".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Move file to a specified folder
     * User with a Update Place permission for a folder and Create Entity  for a Parent Folder can access this method.
     * @param id file id
     * @param folderId folder id
     * @return TemplateVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templatesMoveFile(id: kotlin.String, folderId: kotlin.String) : TemplateVM {
        val localVarResponse = templatesMoveFileWithHttpInfo(id = id, folderId = folderId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TemplateVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Move file to a specified folder
     * User with a Update Place permission for a folder and Create Entity  for a Parent Folder can access this method.
     * @param id file id
     * @param folderId folder id
     * @return ApiResponse<TemplateVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun templatesMoveFileWithHttpInfo(id: kotlin.String, folderId: kotlin.String) : ApiResponse<TemplateVM?> {
        val localVariableConfig = templatesMoveFileRequestConfig(id = id, folderId = folderId)

        return request<Unit, TemplateVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templatesMoveFile
     *
     * @param id file id
     * @param folderId folder id
     * @return RequestConfig
     */
    fun templatesMoveFileRequestConfig(id: kotlin.String, folderId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/rp/v1/Templates/File/{id}/Move/{folderId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"folderId"+"}", encodeURIComponent(folderId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Move specified file to recycle bin
     * User with Delete permission can access the method.
     * @param id file id
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templatesMoveFileToBin(id: kotlin.String) : Unit {
        val localVarResponse = templatesMoveFileToBinWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Move specified file to recycle bin
     * User with Delete permission can access the method.
     * @param id file id
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun templatesMoveFileToBinWithHttpInfo(id: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = templatesMoveFileToBinRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templatesMoveFileToBin
     *
     * @param id file id
     * @return RequestConfig
     */
    fun templatesMoveFileToBinRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/rp/v1/Templates/File/{id}/ToBin".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Prepare specified template to report
     * User with Execute Prepare permission on report and  Create Entity on a prepared report folder can access this method.
     * @param id template id
     * @param prepareTemplateVM Template prepare view model (optional)
     * @return ReportVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templatesPrepare(id: kotlin.String, prepareTemplateVM: PrepareTemplateVM? = null) : ReportVM {
        val localVarResponse = templatesPrepareWithHttpInfo(id = id, prepareTemplateVM = prepareTemplateVM)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ReportVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Prepare specified template to report
     * User with Execute Prepare permission on report and  Create Entity on a prepared report folder can access this method.
     * @param id template id
     * @param prepareTemplateVM Template prepare view model (optional)
     * @return ApiResponse<ReportVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun templatesPrepareWithHttpInfo(id: kotlin.String, prepareTemplateVM: PrepareTemplateVM?) : ApiResponse<ReportVM?> {
        val localVariableConfig = templatesPrepareRequestConfig(id = id, prepareTemplateVM = prepareTemplateVM)

        return request<PrepareTemplateVM, ReportVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templatesPrepare
     *
     * @param id template id
     * @param prepareTemplateVM Template prepare view model (optional)
     * @return RequestConfig
     */
    fun templatesPrepareRequestConfig(id: kotlin.String, prepareTemplateVM: PrepareTemplateVM?) : RequestConfig<PrepareTemplateVM> {
        val localVariableBody = prepareTemplateVM
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/rp/v1/Templates/File/{id}/Prepare".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Recover specified file from bin
     * User with Delete permission can access the method.
     * @param id file id
     * @param recoveryPath  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templatesRecoverFile(id: kotlin.String, recoveryPath: kotlin.String? = null) : Unit {
        val localVarResponse = templatesRecoverFileWithHttpInfo(id = id, recoveryPath = recoveryPath)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Recover specified file from bin
     * User with Delete permission can access the method.
     * @param id file id
     * @param recoveryPath  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun templatesRecoverFileWithHttpInfo(id: kotlin.String, recoveryPath: kotlin.String?) : ApiResponse<Unit?> {
        val localVariableConfig = templatesRecoverFileRequestConfig(id = id, recoveryPath = recoveryPath)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templatesRecoverFile
     *
     * @param id file id
     * @param recoveryPath  (optional)
     * @return RequestConfig
     */
    fun templatesRecoverFileRequestConfig(id: kotlin.String, recoveryPath: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (recoveryPath != null) {
                    put("recoveryPath", listOf(recoveryPath.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/rp/v1/Templates/File/{id}/Recover".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Rename a file
     * User with Update Name permission can access this method.
     * @param id 
     * @param fileRenameVM  (optional)
     * @return TemplateVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templatesRenameFile(id: kotlin.String, fileRenameVM: FileRenameVM? = null) : TemplateVM {
        val localVarResponse = templatesRenameFileWithHttpInfo(id = id, fileRenameVM = fileRenameVM)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TemplateVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Rename a file
     * User with Update Name permission can access this method.
     * @param id 
     * @param fileRenameVM  (optional)
     * @return ApiResponse<TemplateVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun templatesRenameFileWithHttpInfo(id: kotlin.String, fileRenameVM: FileRenameVM?) : ApiResponse<TemplateVM?> {
        val localVariableConfig = templatesRenameFileRequestConfig(id = id, fileRenameVM = fileRenameVM)

        return request<FileRenameVM, TemplateVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templatesRenameFile
     *
     * @param id 
     * @param fileRenameVM  (optional)
     * @return RequestConfig
     */
    fun templatesRenameFileRequestConfig(id: kotlin.String, fileRenameVM: FileRenameVM?) : RequestConfig<FileRenameVM> {
        val localVariableBody = fileRenameVM
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/rp/v1/Templates/File/{id}/Rename".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Make preview for the report.  Generate a new or return exist prepared svg files.  If template was changed will be returned a new.  Pass the &#x60;&#x60; parameter to check prepared timestamp
     * 
     * @param id template id
     * @param previewTemplateVM Model with parameters (optional)
     * @return ExportVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templatesStaticPreview(id: kotlin.String, previewTemplateVM: PreviewTemplateVM? = null) : ExportVM {
        val localVarResponse = templatesStaticPreviewWithHttpInfo(id = id, previewTemplateVM = previewTemplateVM)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ExportVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Make preview for the report.  Generate a new or return exist prepared svg files.  If template was changed will be returned a new.  Pass the &#x60;&#x60; parameter to check prepared timestamp
     * 
     * @param id template id
     * @param previewTemplateVM Model with parameters (optional)
     * @return ApiResponse<ExportVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun templatesStaticPreviewWithHttpInfo(id: kotlin.String, previewTemplateVM: PreviewTemplateVM?) : ApiResponse<ExportVM?> {
        val localVariableConfig = templatesStaticPreviewRequestConfig(id = id, previewTemplateVM = previewTemplateVM)

        return request<PreviewTemplateVM, ExportVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templatesStaticPreview
     *
     * @param id template id
     * @param previewTemplateVM Model with parameters (optional)
     * @return RequestConfig
     */
    fun templatesStaticPreviewRequestConfig(id: kotlin.String, previewTemplateVM: PreviewTemplateVM?) : RequestConfig<PreviewTemplateVM> {
        val localVariableBody = previewTemplateVM
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/rp/v1/Templates/File/{id}/StaticPreview".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Updates contnet of the template. The method is deprecated, use the UpdateContentV2 method instead!
     * 
     * @param id template id
     * @param updateFileContentVM VM with only byte[] with new content (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    @Deprecated(message = "This operation is deprecated.")
    fun templatesUpdateContent(id: kotlin.String, updateFileContentVM: UpdateFileContentVM? = null) : Unit {
        @Suppress("DEPRECATION")
        val localVarResponse = templatesUpdateContentWithHttpInfo(id = id, updateFileContentVM = updateFileContentVM)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Updates contnet of the template. The method is deprecated, use the UpdateContentV2 method instead!
     * 
     * @param id template id
     * @param updateFileContentVM VM with only byte[] with new content (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    @Deprecated(message = "This operation is deprecated.")
    fun templatesUpdateContentWithHttpInfo(id: kotlin.String, updateFileContentVM: UpdateFileContentVM?) : ApiResponse<Unit?> {
        @Suppress("DEPRECATION")
        val localVariableConfig = templatesUpdateContentRequestConfig(id = id, updateFileContentVM = updateFileContentVM)

        return request<UpdateFileContentVM, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templatesUpdateContent
     *
     * @param id template id
     * @param updateFileContentVM VM with only byte[] with new content (optional)
     * @return RequestConfig
     */
    @Deprecated(message = "This operation is deprecated.")
    fun templatesUpdateContentRequestConfig(id: kotlin.String, updateFileContentVM: UpdateFileContentVM?) : RequestConfig<UpdateFileContentVM> {
        val localVariableBody = updateFileContentVM
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/rp/v1/Templates/File/{id}/Content".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Updates contnet of the template.
     * 
     * @param id template id
     * @param fileContent 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templatesUpdateContentV2(id: kotlin.String, fileContent: java.io.File) : Unit {
        val localVarResponse = templatesUpdateContentV2WithHttpInfo(id = id, fileContent = fileContent)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Updates contnet of the template.
     * 
     * @param id template id
     * @param fileContent 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun templatesUpdateContentV2WithHttpInfo(id: kotlin.String, fileContent: java.io.File) : ApiResponse<Unit?> {
        val localVariableConfig = templatesUpdateContentV2RequestConfig(id = id, fileContent = fileContent)

        return request<Map<String, PartConfig<*>>, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templatesUpdateContentV2
     *
     * @param id template id
     * @param fileContent 
     * @return RequestConfig
     */
    fun templatesUpdateContentV2RequestConfig(id: kotlin.String, fileContent: java.io.File) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "FileContent" to PartConfig(body = fileContent, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/rp/v2/Templates/File/{id}/Content".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Update a files&#39;s icon
     * User with Update Icon permission can access this method.
     * @param id 
     * @param fileIconVM  (optional)
     * @return TemplateVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templatesUpdateIcon(id: kotlin.String, fileIconVM: FileIconVM? = null) : TemplateVM {
        val localVarResponse = templatesUpdateIconWithHttpInfo(id = id, fileIconVM = fileIconVM)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TemplateVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update a files&#39;s icon
     * User with Update Icon permission can access this method.
     * @param id 
     * @param fileIconVM  (optional)
     * @return ApiResponse<TemplateVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun templatesUpdateIconWithHttpInfo(id: kotlin.String, fileIconVM: FileIconVM?) : ApiResponse<TemplateVM?> {
        val localVariableConfig = templatesUpdateIconRequestConfig(id = id, fileIconVM = fileIconVM)

        return request<FileIconVM, TemplateVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templatesUpdateIcon
     *
     * @param id 
     * @param fileIconVM  (optional)
     * @return RequestConfig
     */
    fun templatesUpdateIconRequestConfig(id: kotlin.String, fileIconVM: FileIconVM?) : RequestConfig<FileIconVM> {
        val localVariableBody = fileIconVM
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/rp/v1/Templates/File/{id}/Icon".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Update permissions
     * 
     * @param id 
     * @param updateFilePermissionsVM  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templatesUpdatePermissions(id: kotlin.String, updateFilePermissionsVM: UpdateFilePermissionsVM? = null) : Unit {
        val localVarResponse = templatesUpdatePermissionsWithHttpInfo(id = id, updateFilePermissionsVM = updateFilePermissionsVM)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update permissions
     * 
     * @param id 
     * @param updateFilePermissionsVM  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun templatesUpdatePermissionsWithHttpInfo(id: kotlin.String, updateFilePermissionsVM: UpdateFilePermissionsVM?) : ApiResponse<Unit?> {
        val localVariableConfig = templatesUpdatePermissionsRequestConfig(id = id, updateFilePermissionsVM = updateFilePermissionsVM)

        return request<UpdateFilePermissionsVM, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templatesUpdatePermissions
     *
     * @param id 
     * @param updateFilePermissionsVM  (optional)
     * @return RequestConfig
     */
    fun templatesUpdatePermissionsRequestConfig(id: kotlin.String, updateFilePermissionsVM: UpdateFilePermissionsVM?) : RequestConfig<UpdateFilePermissionsVM> {
        val localVariableBody = updateFilePermissionsVM
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/rp/v1/Templates/File/{id}/permissions".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Update tags
     * User with Update Tags permission can access this method.
     * @param id 
     * @param fileTagsUpdateVM  (optional)
     * @return TemplateVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templatesUpdateTags(id: kotlin.String, fileTagsUpdateVM: FileTagsUpdateVM? = null) : TemplateVM {
        val localVarResponse = templatesUpdateTagsWithHttpInfo(id = id, fileTagsUpdateVM = fileTagsUpdateVM)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TemplateVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update tags
     * User with Update Tags permission can access this method.
     * @param id 
     * @param fileTagsUpdateVM  (optional)
     * @return ApiResponse<TemplateVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun templatesUpdateTagsWithHttpInfo(id: kotlin.String, fileTagsUpdateVM: FileTagsUpdateVM?) : ApiResponse<TemplateVM?> {
        val localVariableConfig = templatesUpdateTagsRequestConfig(id = id, fileTagsUpdateVM = fileTagsUpdateVM)

        return request<FileTagsUpdateVM, TemplateVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templatesUpdateTags
     *
     * @param id 
     * @param fileTagsUpdateVM  (optional)
     * @return RequestConfig
     */
    fun templatesUpdateTagsRequestConfig(id: kotlin.String, fileTagsUpdateVM: FileTagsUpdateVM?) : RequestConfig<FileTagsUpdateVM> {
        val localVariableBody = fileTagsUpdateVM
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/rp/v1/Templates/File/{id}/UpdateTags".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Upload a file to the specified folder. The method is deprecated, use the UploadFileV2 method instead!
     * User with Create Entity permission can access this method.
     * @param id Identifier of folder
     * @param templateCreateVM file&#39;s view model (optional)
     * @return TemplateVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    @Deprecated(message = "This operation is deprecated.")
    fun templatesUploadFile(id: kotlin.String, templateCreateVM: TemplateCreateVM? = null) : TemplateVM {
        @Suppress("DEPRECATION")
        val localVarResponse = templatesUploadFileWithHttpInfo(id = id, templateCreateVM = templateCreateVM)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TemplateVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Upload a file to the specified folder. The method is deprecated, use the UploadFileV2 method instead!
     * User with Create Entity permission can access this method.
     * @param id Identifier of folder
     * @param templateCreateVM file&#39;s view model (optional)
     * @return ApiResponse<TemplateVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    @Deprecated(message = "This operation is deprecated.")
    fun templatesUploadFileWithHttpInfo(id: kotlin.String, templateCreateVM: TemplateCreateVM?) : ApiResponse<TemplateVM?> {
        @Suppress("DEPRECATION")
        val localVariableConfig = templatesUploadFileRequestConfig(id = id, templateCreateVM = templateCreateVM)

        return request<TemplateCreateVM, TemplateVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templatesUploadFile
     *
     * @param id Identifier of folder
     * @param templateCreateVM file&#39;s view model (optional)
     * @return RequestConfig
     */
    @Deprecated(message = "This operation is deprecated.")
    fun templatesUploadFileRequestConfig(id: kotlin.String, templateCreateVM: TemplateCreateVM?) : RequestConfig<TemplateCreateVM> {
        val localVariableBody = templateCreateVM
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/rp/v1/Templates/Folder/{id}/File".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Alternative api for upload a file to the specified folder!
     * User with Create Entity permission can access this method.
     * @param id Identifier of folder
     * @param fileContent 
     * @param tags  (optional)
     * @param icon  (optional)
     * @return TemplateVM
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun templatesUploadFileV2(id: kotlin.String, fileContent: java.io.File, tags: kotlin.collections.List<kotlin.String>? = null, icon: java.io.File? = null) : TemplateVM {
        val localVarResponse = templatesUploadFileV2WithHttpInfo(id = id, fileContent = fileContent, tags = tags, icon = icon)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TemplateVM
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Alternative api for upload a file to the specified folder!
     * User with Create Entity permission can access this method.
     * @param id Identifier of folder
     * @param fileContent 
     * @param tags  (optional)
     * @param icon  (optional)
     * @return ApiResponse<TemplateVM?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun templatesUploadFileV2WithHttpInfo(id: kotlin.String, fileContent: java.io.File, tags: kotlin.collections.List<kotlin.String>?, icon: java.io.File?) : ApiResponse<TemplateVM?> {
        val localVariableConfig = templatesUploadFileV2RequestConfig(id = id, fileContent = fileContent, tags = tags, icon = icon)

        return request<Map<String, PartConfig<*>>, TemplateVM>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation templatesUploadFileV2
     *
     * @param id Identifier of folder
     * @param fileContent 
     * @param tags  (optional)
     * @param icon  (optional)
     * @return RequestConfig
     */
    fun templatesUploadFileV2RequestConfig(id: kotlin.String, fileContent: java.io.File, tags: kotlin.collections.List<kotlin.String>?, icon: java.io.File?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "Tags" to PartConfig(body = tags, headers = mutableMapOf()),
            "Icon" to PartConfig(body = icon, headers = mutableMapOf()),
            "FileContent" to PartConfig(body = fileContent, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/rp/v2/Templates/Folder/{id}/File".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
